1.spring-boot启动流程
	1.1主函数调用
	ConfigurableApplicationContext ctx = SpringApplication.run(MySpringApplication.class, args);
	
	--------------------------------实例化对象-------------------------------------
	1.2实例化SpringApplication对象
	new SpringApplication(sources)
	
	1.3实例化时调用 
	initialize(sources);
	
	1.4具体方法如下
	//判断是否是web的环境
	this.webEnvironment = deduceWebEnvironment();   -----1.4.1
	//读取META-INF/spring.factories文件中配置的上下文初始化器ApplicationContextInitializer实例化并设置到SpringApplication的initializers集合中
	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));   -----1.4.2
	//读取META-INF/spring.factories文件中配置的应用监听器ApplicationListener实例化并设置到SpringApplication的listeners集合中
	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
	//设置主类
	this.mainApplicationClass = deduceMainApplicationClass();
	
		1.4.1 deduceWebEnvironment()方法
		推断是否是web的环境，通过判断是否存在
		private static final String[] WEB_ENVIRONMENT_CLASSES = { "javax.servlet.Servlet",
			"org.springframework.web.context.ConfigurableWebApplicationContext" }; 这两个类，判断是否是web环境
		例子中	mainApplicationClass = false;
		
		1.4.2 setInitializers()
			  通过SpringFactoriesLoader的静态方法loadFactoryNames()加载classpath中的所有的上下文初始化器
		      通过SpringApplication对象的createSpringFactoriesInstances()方法实例化所有的上下文初始化器
			  setListeners()与setInitializers()方法类似
	
	--------------------------------执行SpringApplication对象run方法-------------------------------------	
	1.5 具体方法如下
	public ConfigurableApplicationContext run(String... args) {
		//初始化计时器
		StopWatch stopWatch = new StopWatch();
		//计时器启动
		stopWatch.start();
		//
		ConfigurableApplicationContext context = null;
		FailureAnalyzers analyzers = null;
		configureHeadlessProperty();
		
		//同上1.4.2 获取META-INF/spring.factories文件中配置的应用启动监听器SpringApplicationRunListeners并实例化
		SpringApplicationRunListeners listeners = getRunListeners(args);
		//监听器启动
		listeners.starting();                                                                -----1.5.1
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(
					args);
			
			//准备环境对象
			ConfigurableEnvironment environment = prepareEnvironment(listeners,
					applicationArguments);
					
			//准备打印对象
			Banner printedBanner = printBanner(environment);
			
			//创建上下文对象
			context = createApplicationContext();
			
			//错误原因分析
			analyzers = new FailureAnalyzers(context);
			
			//准备上下文对象
			prepareContext(context, environment, listeners, applicationArguments,
					printedBanner);
					
			//刷新上下文对象
			refreshContext(context);
			
			//
			afterRefresh(context, applicationArguments);
			
			//发布启动完成事件
			listeners.finished(context, null);
			
			//计时器结束
			stopWatch.stop();
			
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass)
						.logStarted(getApplicationLog(), stopWatch);
			}
			return context;
		}
		catch (Throwable ex) {
			handleRunFailure(context, listeners, analyzers, ex);
			throw new IllegalStateException(ex);
		}
	}
	
	
		1.5.1 listeners.starting() 遍历所有的应用启动监听器并执行每一个监听器的starting()方法
		for (SpringApplicationRunListener listener : this.listeners) {
			listener.starting();
		}
		在springboot项目中我们通过
		List<String> listens  = SpringFactoriesLoader.loadFactoryNames(SpringApplicationRunListener.class, null);
    	for(String l:listens)
    	{
    		System.out.println(l);
    	}
		获取到加载的默认SpringApplicationRunListener为org.springframework.boot.context.event.EventPublishingRunListener
		EventPublishingRunListener其实就是一个事件发布的监听器
		
		public void starting() {
		this.initialMulticaster
				.multicastEvent(new ApplicationStartedEvent(this.application, this.args));
		}
		
		
		
		最后执行的是之前加载的应用监听器
		for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
			Executor executor = getTaskExecutor();
			if (executor != null) {
				executor.execute(new Runnable() {
					@Override
					public void run() {
						invokeListener(listener, event);
					}
				});
			}
			else {
				invokeListener(listener, event);
			}
		}
		
		
		------------------最重要的refreshContext()方法为spring bean构建的核心方法-----------
			@Override
		public void refresh() throws BeansException, IllegalStateException {
			synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
	
	
	
	
	------------------------初始化所有非懒加载的单例bean------------------------
	
	// Instantiate all remaining (non-lazy-init) singletons.
	finishBeanFactoryInitialization(beanFactory);
	主要的方法为 
	BeanFactory.getBean(beanNm) 实际对象为 DefaultListableBeanFactory.getBean(beanNm);
	
	
	
	-----------------初始化bean整体流程--------------
	
	1. InstantiationAwareBeanPostProcessor postProcessBeforeInstantiation......
		执行InstantiationAwareBeanPostProcessor对象的postProcessBeforeInstantiation方法
		（InstantiationAwareBeanPostProcessor接口中自定义的方法，bean对象实例化之前，bean对象还不存在）
		postProcessBeforeInstantiation方法是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。
		由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。
		如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；---------------------------------------------
	                                            ↓                                                                                                                    ↓
	2. MchtServerImpl construtor......                                                                                                                               ↓
		bean对象实例化                                                                                                                                               ↓
	                                            ↓
	3. InstantiationAwareBeanPostProcessor postProcessAfterInstantiation......                                                                                       ↓
		执行InstantiationAwareBeanPostProcessor对象的postProcessAfterInstantiation方法
		（InstantiationAwareBeanPostProcessor接口中自定义的方法，bean对象实例化之后，bean对象已存在）                                                                ↓
	                                            ↓
	4. InstantiationAwareBeanPostProcessor postProcessPropertyValues......
		执行InstantiationAwareBeanPostProcessor对象的postProcessPropertyValues方法                                                                                   ↓
		（InstantiationAwareBeanPostProcessor接口中自定义的方法，可修改bean对象的属性值）                                                                       
	                                            ↓											
	5. MchtServerImpl set property.....                                                                                                                              ↓
		bean对象设置属性
	                                            ↓											
	6. BeanNameAware setBeanName.....
		bean对象如果实现了BeanNameAware接口执行setBeanName方法设置bean名称                                                                                           ↓
	                                            ↓	
	7. BeanFactoryAware setBeanFactory.....
		bean对象如果实现了BeanFactoryAware接口执行setBeanFactory方法设置beanFactory
	                                            ↓												
	8. BeanPostProcessor postProcessBeforeInitialization...... 
	    执行BeanPostProcessor对象的postProcessBeforeInitialization 方法，在执行init-method方法前执行                                                                 ↓
	                                            ↓											
	9. InstantiationAwareBeanPostProcessor postProcessBeforeInitialization...... 
	    执行InstantiationAwareBeanPostProcessor对象的postProcessBeforeInitialization 方法，在执行init-method方法前执行
		由于InstantiationAwareBeanPostProcessor继承自BeanPostProcessor接口，每一个InstantiationAwareBeanPostProcessor对象都是一个BeanPostProcessor对象
	                                            ↓
	10. InitializingBean afterPropertiesSet..... 
	    bean对象如果实现了InitializingBean接口，则执行 InitializingBean 的 afterPropertiesSet 方法
	                                            ↓												
	11. MchtServerImpl init-method......
	    执行bean定义的初始化方法                                                                                                                                     ↓
	                                            ↓											                                                                         ↓	
	12. BeanPostProcessor postProcessAfterInitialization......                                                                                                      ←
	    执行BeanPostProcessor对象的 postProcessAfterInitialization 方法，在执行init-method方法后执行
	                                            ↓												
	13. InstantiationAwareBeanPostProcessor postProcessAfterInitialization......
	    执行 InstantiationAwareBeanPostProcessor 对象的 postProcessAfterInitialization 方法，在执行init-method方法后执行
	    同9                                       										
												
												
	

	
	------------------beanFactory三级缓存----------
	//一级缓存
	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);

	//三级缓存
	/** Cache of singleton factories: bean name --> ObjectFactory */
	private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);

	//二级缓存
	/** Cache of early singleton objects: bean name --> bean instance */
	private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
	
	
	-------------------初始化实例--------------											
	<bean id="mchtServer" class="org.dubbo.server.impl.SimpleBeanMcht">
		<property name="oprServer" ref="simpleBeanOpr"></property>
	</bean>
    <bean id="oprServer" class="org.dubbo.server.impl.SimpleBeanOpr">
		<property name="mchtServer" ref="simpleBeanMcht"></property>
	</bean>
	
	定义了两个bean ：mchtServer ，oprServer 他们相互依赖
	

	1. getBean("mchtServer");                        -----DefaultListableBeanFactory(AbstractBeanFactory) 对象方法
	   初始化 mcht 入口											
												
	2. doGetBean(mchtServer, null, null, false);               -----DefaultListableBeanFactory(AbstractBeanFactory) 对象方法
	   实际执行方法
	
	3. getSingleton(mchtServer, true);                     -----DefaultListableBeanFactory(DefaultSingletonBeanRegistry) 对象方法
         尝试从缓存中获取 mchtServer 还没有创建，返回为空
		
		protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		//从一级缓存中获取bean
		Object singletonObject = this.singletonObjects.get(beanName);
		//如果没有获取到，则判断在正在创建对象 singletonsCurrentlyInCreation 集合中存在
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {
				//从二级缓存中获取bean
				singletonObject = this.earlySingletonObjects.get(beanName);
				if (singletonObject == null && allowEarlyReference) {
				//从三级缓存中获取bean
					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return (singletonObject != NULL_OBJECT ? singletonObject : null);
		}
		
	4. markBeanAsCreated(mchtServer)                ----DefaultListableBeanFactory(AbstractBeanFactory)										
		添加 要创建的bean名称 mchtServer 到 alreadyCreated 集合中	

	5. 	sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {                ----DefaultListableBeanFactory(AbstractBeanFactory)

						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					});

		构建一个内部类对象，并作为参数传给 getSingleton 方法
		new ObjectFactory<Object>() 是一个回调方法对象
		beanFactory通过 getSingleton 方法，调用内部类的 getObject 方法
		getObject又回调 beanFactory 的 createBean 方法完成创建bean
	
	6. public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {     ----DefaultListableBeanFactory(DefaultSingletonBeanRegistry)
		Assert.notNull(beanName, "'beanName' must not be null");
		synchronized (this.singletonObjects) {
		    //同步一级缓存并再次从一级缓存查找 mchtServer 对象
			Object singletonObject = this.singletonObjects.get(beanName);
			if (singletonObject == null) {
				if (this.singletonsCurrentlyInDestruction) {
					throw new BeanCreationNotAllowedException(beanName,
							"Singleton bean creation not allowed while singletons of this factory are in destruction " +
							"(Do not request a bean from a BeanFactory in a destroy method implementation!)");
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
				}
				
				//将 mchtServer 名称添加到 singletonsCurrentlyInCreation 集合中
				beforeSingletonCreation(beanName);
				boolean newSingleton = false;
				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = new LinkedHashSet<Exception>();
				}
				try {
				    //核心 调用内部类的回调方法 getObject
					singletonObject = singletonFactory.getObject();
					newSingleton = true;
				}
				catch (IllegalStateException ex) {
					// Has the singleton object implicitly appeared in the meantime ->
					// if yes, proceed with it since the exception indicates that state.
					singletonObject = this.singletonObjects.get(beanName);
					if (singletonObject == null) {
						throw ex;
					}
				}
				catch (BeanCreationException ex) {
					if (recordSuppressedExceptions) {
						for (Exception suppressedException : this.suppressedExceptions) {
							ex.addRelatedCause(suppressedException);
						}
					}
					throw ex;
				}
				finally {
					if (recordSuppressedExceptions) {
						this.suppressedExceptions = null;
					}
					afterSingletonCreation(beanName);
				}
				if (newSingleton) {
					addSingleton(beanName, singletonObject);
				}
			}
			return (singletonObject != NULL_OBJECT ? singletonObject : null);
		}
	}											
												
		6.1 singletonFactory.getObject(); 
			在5中描述了getObject又回调 beanFactory 的 createBean 方法完成创建bean
			
	7. protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) ----DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory)
		开始创建bean 
		
	8.	Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		实例化之前执行 InstantiationAwareBeanPostProcessors 中的 applyBeanPostProcessorsBeforeInstantiation >>>>>>对应流程中的1
		
		protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
		Object bean = null;
		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
			// Make sure bean class is actually resolved at this point.
			if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
				Class<?> targetType = determineTargetType(beanName, mbd);
				if (targetType != null) {
					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
					if (bean != null) {
					//需要注意的是如果 applyBeanPostProcessorsAfterInitialization 返回一个对象
					 //之后直接执行 applyBeanPostProcessorsAfterInitialization 并返回 此对象（比如一个代理对象）
						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
					}
				}
			}
			mbd.beforeInstantiationResolved = (bean != null);
		}
		return bean;
	}
												
	9. Object beanInstance = doCreateBean(beanName, mbdToUse, args);
       真正创建bean的方法
		
		protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)  ----DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory)
			throws BeanCreationException {

		//9.1 定义一个bean的包装类
		// 此包装类主要用来设置 bean的属性值
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
		    //9.2 实例化包装类对象
			//调用 mchtServer 类的无参构造函数实例化 mchtServer 对象并封装成一个包装对象                   >>>>>>对应流程中的2
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		
		//9.3 获取真正的bean mchtServer 
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		
		//9.4 获取simpleBeanMcht 类型
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
		mbd.resolvedTargetType = beanType;

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isDebugEnabled()) {
				logger.debug("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			//9.5 构建一个内部类ObjectFactory对象 并添加到三级缓存 singletonFactories 中
			// 用于提前暴露，解决循环依赖问题
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
		    //9.6 初始化 simpleBeanMcht 对象 ，给刚实例化的 simpleBeanMcht 对象设置属性值
			populateBean(beanName, mbd, instanceWrapper);
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
			}
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
		}

		return exposedObject;
	}
												
	10. populateBean(beanName, mbd, instanceWrapper);											
		初始化 simpleBeanMcht 对象 ，给刚实例化的 simpleBeanMcht 对象设置属性值
		
        //遍历所有的InstantiationAwareBeanPostProcessor 接口对象并执行 postProcessAfterInstantiation 方法 >>>>>>对应流程中的3
		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						continueWithPropertyPopulation = false;
						break;
					}
				}
			}
		}
		
		//遍历所有的InstantiationAwareBeanPostProcessor 接口对象并执行 postProcessPropertyValues 方法 >>>>>>对应流程中的4
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvs == null) {
							return;
						}
					}
			
	11. applyPropertyValues(beanName, mbd, bw, pvs);                                                >>>>>>对应流程中的5 
		simpleBeanMcht 对象属性初始化
		
		//11.1 实例化一个 bean定义中值的处理器
		BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);
		
		//11.2 遍历beanDefinition中的所有的属性定义
		// simpleBeanMcht 对象有一个属性   oprServer;
		for (PropertyValue pv : original) {
			if (pv.isConverted()) {
				deepCopy.add(pv);
			}
			else {
				//11.3 获取属性名称 oprServer
				String propertyName = pv.getName();
				
				//11.4 获取属性值 由于 oprServer 属性也是一个bean 所有获取到的 originalValue 为一个 RuntimeBeanReference 引用对象
				Object originalValue = pv.getValue();
				
				//11.5 处理 oprServer 属性
				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
				
				Object convertedValue = resolvedValue;
				boolean convertible = bw.isWritableProperty(propertyName) &&
						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
				if (convertible) {
					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
				}
				// Possibly store converted value in merged bean definition,
				// in order to avoid re-conversion for every created bean instance.
				if (resolvedValue == originalValue) {
					if (convertible) {
						pv.setConvertedValue(convertedValue);
					}
					deepCopy.add(pv);
				}
				else if (convertible && originalValue instanceof TypedStringValue &&
						!((TypedStringValue) originalValue).isDynamic() &&
						!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
					pv.setConvertedValue(convertedValue);
					deepCopy.add(pv);
				}
				else {
					resolveNecessary = true;
					deepCopy.add(new PropertyValue(pv, convertedValue));
				}
			}
		}
												
												
	 12. valueResolver.resolveValueIfNecessary(pv, originalValue);                   ------BeanDefinitionValueResolver.resolveValueIfNecessary
	     处理 oprServer 属性
		 
		 //判断属性值类型 当前属性 oprServer 为 RuntimeBeanReference 类型
	    if (value instanceof RuntimeBeanReference) {
			RuntimeBeanReference ref = (RuntimeBeanReference) value;
			return resolveReference(argName, ref);
		}
		
		

	13. resolveReference(Object argName, RuntimeBeanReference ref)                  ------BeanDefinitionValueResolver.resolveReference
        具体处理方法
		
		//调用beanFactory 方法获取 oprServer 对象
		Object bean = this.beanFactory.getBean(refName);
		
	14. 此时 按照 上面的流程 再创建一个 oprServer 实例
	
	    ------------------缓存中的对象------------------
		一级缓存 singletonObjects >>>
		二级缓存 earlySingletonObjects >>>
		三级缓存 singletonFactories >>> 	ObjectFactory<simpleBeanMcht> , ObjectFactory<simpleBeanOpr>
		----------------------------------------------------
		
	15. oprServer	创建成功后，需要给oprServer对象初始化属性 mchtServer
	
	     按照1的步骤，同样调用 getSingleton 方法获取对象 mchtServer
		
		protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		Object singletonObject = this.singletonObjects.get(beanName);
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {
				singletonObject = this.earlySingletonObjects.get(beanName);
				if (singletonObject == null && allowEarlyReference) {
					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return (singletonObject != NULL_OBJECT ? singletonObject : null);
	}
	
	    15.1 从缓存中寻找，由于 当前一级缓存，二级缓存没有 mchtServer 
			 从三级缓存中 获取 mchtServer 对象，等到一个内部类对象
			 new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
				});
		15.2. 调用内部类对象的   getObject() 方法，回调
	     getEarlyBeanReference(mchtServer, mbd, bean); 方法
		 这个方法其实是用于得到目标对象的代理对象（如果存在代理）
		 
		15.3 将得到的代理对象 放入二级缓存，从三级缓存中移除
		
		 ------------------缓存中的对象------------------
		一级缓存 singletonObjects >>>
		二级缓存 earlySingletonObjects >>>  Proxy(mchtServer)
		三级缓存 singletonFactories >>> 	 ObjectFactory<oprServer>
		----------------------------------------------------
	
	16. 将得到的 mchtServer 对象设置为 oprServer 属性
	
	17. oprServer 对象创建完成
		 
	18. beanFactory.initializeBean(oprServer, exposedObject, mbd);	 
	    
	   
	    18.1 beanFactory.invokeAwareMethods(oprServer)   
            		执行aware方法                                            >>>对应流程 6-7
		
		18.2 beanFactory.applyBeanPostProcessorsBeforeInitialization(oprServer)    
		    执行 BeanPostProcessor postProcessBeforeInitialization 方法            >>>对应流程 8-9
		
		18.3 beanFactory.invokeInitMethods(oprServer, wrappedBean, mbd);     
		    执行 InitializingBean 接口方法,执行 init-method 方法                >>>对应流程 10-11
		
		18.4 beanFactory.applyBeanPostProcessorsAfterInitialization(wrappedBean,oprServer);  
            执行 BeanPostProcessor postProcessAfterInitialization 方法      		   >>>对应流程 12-13
			
	19 . getSingleton(oprServer, false); 查询当前对象 是否在 二级缓存中                                    
	    
		//尝试从一级、二级缓存中获取对象，如果有则替换对象，
			//此时没有，则直接返回 oprServer 对象
			Object earlySingletonReference = getSingleton(oprServer, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
	
			
	20. createBean(oprServer) 执行完成，返回 到 beanFactory.getSingleton(oprServer, new ObjectFactory<Object>())
	     执行addSingleton(beanName, singletonObject);
		 
		    一级缓存添加 对象 oprServer
			二三级缓存移除 oprServer 对象
		    this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		
		 ------------------缓存中的对象------------------
		一级缓存 singletonObjects >>> oprServer
		二级缓存 earlySingletonObjects >>>  Proxy(mchtServer)
		三级缓存 singletonFactories >>> 	
		----------------------------------------------------
		
	21. 	beanFactory.getSingleton(oprServer, new ObjectFactory<Object>()) 执行完成，返回到 getSingleton 方法中
	
	        
			
	22.  oprServer 对象创建完成，按照之前的步骤给 mchtServer 设置属性 oprServer   
	     populateBean(mchtServer, mbd, instanceWrapper);返回
	     
	
	23.   getSingleton(mchtServer, false);  
	    尝试从二级缓存中获取 mchtServer ，当前获取到 ，则用二级缓存中的对象 替换当前bean 作为 mchtServer bean
		
    24. createBean(mchtServer) 执行完成，返回 到 beanFactory.getSingleton(mchtServer, new ObjectFactory<Object>())
	     执行addSingleton(beanName, singletonObject);
		 
		    一级缓存添加 对象 mchtServer（二级缓存中的对象）
			二三级缓存移除 mchtServer 对象
		    this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		
		 ------------------缓存中的对象------------------
		一级缓存 singletonObjects >>> oprServer,Proxy(mchtServer) 
		二级缓存 earlySingletonObjects >>>  
		三级缓存 singletonFactories >>> 	
		----------------------------------------------------
		                                                         ↑
    --------------------------------------------------两个循环依赖对象创建完成--------------------------------------------------------	
	
	
		----------------------getBean整体方法调用流程-----------------
		'-->': 方法调用
		'A': beanName
		'B': beanName
		
		>>beanFactory.getBean(A)
		-->beanFactory.doGetBean(A, Class<T>, Object[], boolean)
		
		   -->beanFactory.getSingleton(A, new ObjectFactory<Object>())
		   
		      -->objectFactory.getObject()
			  
				 -->beanFactory.createBean(A, mbd, args)
				 
					-->beanFactory.resolveBeforeInstantiation(A, RootBeanDefinition mbd)                            -----流程1 执行 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation 方法
			           beanFactory.doCreateBean(A, mbdToUse, args);
					   
					   -->beanFactory.createBeanInstance(A, mbdToUse, args);                                        -----流程2 使用无参构造函数实例化 A
						  beanFactory.addSingletonFactory(A, new ObjectFactory<Object>())                           -----将A对象封装成一个内部类 ObjectFactory 对象放入第三缓存
			              populateBean(A, mbd, instanceWrapper);
						  
			              -->InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(A)                   -----流程3 执行 InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation 方法                     
					         InstantiationAwareBeanPostProcessor.postProcessPropertyValues(A)                       -----流程4 执行 InstantiationAwareBeanPostProcessor.postProcessPropertyValues 方法    
                             beanFactory.applyPropertyValues(A, mbd, bw, pvs);			                            -----流程5 初始化对象A属性
		
		               -->beanFactory.initializeBean(A, exposedObject, mbd);
					   
					      -->beanFactory.invokeAwareMethods(A)                                                      -----流程6-7 执行 Aware 接口方法
						     beanFactory.applyBeanPostProcessorsBeforeInitialization(wrappedBean, A);               -----流程8-9 执行 BeanPostProcessor postProcessBeforeInitialization 方法
							 beanFactory.invokeInitMethods(A, wrappedBean, mbd);        
							 
		                     -->((InitializingBean) bean).afterPropertiesSet();                                     -----流程10 执行 InitializingBean 接口方法
							     beanFactory.invokeCustomInitMethod(A, bean, mbd);                                  -----流程11 执行 init-method 自定义初始化方法
								 
						  -->beanFactory.applyBeanPostProcessorsAfterInitialization(wrappedBean,A);                 -----流程12-13 执行 BeanPostProcessor postProcessAfterInitialization 接口方法
						  
					   -->beanFactory.getSingleton(A, false);                                                       -----尝试从二级缓存中获取 A 对象， 如果有 则替换当前 A对象 并返回（一般是A的代理对象）
		
			  -->addSingleton(beanName, singletonObject);                                                           -----返回到 getSingleton 方法中
			                                                                                                             将bean从二级缓存、三级缓存中移除，添加到一级缓存，对象创建成功
			                                                                                                              
		
		
		循环依赖简单流程：
		
		A->B
		B->A
		 
		1. A实例化 ，放一个能获取A对象(或代理对象 ProxyA )的对象 FactoryA 放入 第三缓存
		
		2. A设置B属性，B初始化 ，放一个能获取B对象(或代理对象ProxyB)的对象FactoryB 放入 第三缓存
		
		3. B设置A属性，从第三缓存中获取到了 A对象的 FactoryA ,调用 FactoryA 的get方法 获取到 A(或代理对象 ProxyA)，放入第二缓存，并设置为A属性 
		      B.A = A（ProxyA）
			  
	    4. B初始化完成，检查 B是否在第二缓存中，当前B不在第二缓存，则返回B 
		    
		5. 完成B对象的所有操作，将B对象从第三缓存移除，放入第一缓存，并设置为 A 的 B 属性
		       A.B = B
			   
		6. A初始化完成，检查 A是否在第二缓存中，当前A在第二缓存，则用第二缓存中的对象（A或代理对象 ProxyA）替换 A ，返回A
		
		7. 完成A对象的所有操作，将A对象从第二缓存移除，放入第一缓存，并返回 A(或ProxyA)
		
		
		
		
		
		
		---------------spring aop---------------
		
		准备知识
		
		1.关于 finally 中的方法何时执行
		
		public class TestFinal {
	
			int num = 1;
	
			public int getNum()
			{
				System.out.println(" getNum invoke ");
				num++;
				return num;
			}
	
			public void doFinally()
			{
				System.out.println(" doFinally ");
				num++;
			}
	
			public int getCount()
			{
			try{
				return getNum();
				}finally
				{
				doFinally();
				}
			}
	
			public static void main(String[] args) {
				TestFinal fin = new TestFinal();
				System.out.println(fin.getCount());   //这里打印 2还是3？
			}

		}
		
		//分析上面的代码
		 0  aload_0 [this]                                                          //将本地变量表0 位置的 值推入操作数栈（当前对象地址）
         1  invokevirtual org.dubbo.server.test.TestFinal.getNum() : int [38]       //弹出栈顶的值this，执行 getNum 方法，将结果放入 栈顶 2
		 4  istore_2                                                                //弹出栈顶数 2 ，保存到本地变量表  2 位置
		 5  aload_0 [this]                                                          //将本地变量表0 位置的 值推入操作数栈（当前对象地址）
		 6  invokevirtual org.dubbo.server.test.TestFinal.doFinally() : void [40]   //弹出栈顶的值this，执行 doFinally 方法，将结果放入 栈顶 3
		 9  iload_2                                                                 //本地变量表2 位置的 值推入操作数栈（2）
		 10  ireturn                                                                //返回栈顶（2）
		 -----异常处理字节码-----                                                   
		 11  astore_1
		 12  aload_0 [this]
		 13  invokevirtual org.dubbo.server.test.TestFinal.doFinally() : void [40]
		 16  aload_1
		 17  athrow
		 -----异常表-----
		 Exception Table:
        [pc: 0, pc: 5] -> 11 when : any                                             //pc:0 异常发生的开始指令
		                                                                            //pc:5 异常发生的结束指令
																					//-> 11 :异常发生时跳转的目标指令
																					// when : any     异常类型，任何异常
																					//当在0-5 指令执行时抛出异常，与当前表里面的异常类型一致，则跳到 11行指令
		
		
		//所以上面的方法打印
			>>getNum invoke 
			>>doFinally 
			>>2
		
		
		
		2. 关于责任链模式
		
		--------------------------------方法拦截器抽象------------------------------------
		public interface MethodInterceptor {
            //执行过滤器
			public Object invoke(MethodInvocation methodInvocation);
		}
		
		--------------------------------两个拦截器实现类----------------------------------
		//方法之前执行执行的拦截器
		public class MethodBeforeAdviceInterceptor implements MethodInterceptor{
			@Override
			public Object invoke(MethodInvocation methodInvocation) {
				System.out.println(" MethodBeforeAdviceInterceptor invoke...");                       //前置方法
				return methodInvocation.proceed();
			}
		}
		
		//方法执行后拦截器
		public class AspectJAfterAdvice implements MethodInterceptor{
			@Override
			public Object invoke(MethodInvocation methodInvocation) {
				try {
				return methodInvocation.proceed();
				}
			finally {
				System.out.println(" AspectJAfterAdvice invoke... ");                                 //后置方法
				}
			}
		}
		
		--------------------------------责任链方法执行抽象------------------------
		public interface MethodInvocation {
			//执行责任链方法
			public Object proceed();
			}

		--------------------------------实现责任链方法执行器---------------------
		public class ReflectiveMethodInvocation implements MethodInvocation{
            private TestFinal target;   //目标方法
			private MethodInterceptor[] methodInterceptors ;  //拦截器
			int currentIdx;                                   //当前执行拦截器索引
	
			public ReflectiveMethodInvocation(TestFinal target)
			{
				this.target = target;
				methodInterceptors = new MethodInterceptor[]{new AspectJAfterAdvice(),new MethodBeforeAdviceInterceptor()};
				currentIdx = 0;
			}
	
			@Override
			public Object proceed() {
				//拦截器执行完毕，执行目标方法
				if(currentIdx==methodInterceptors.length)
					{
					return target.getNum();                                                    
					}
		
				MethodInterceptor currentInterceptor = methodInterceptors[currentIdx++];
				return currentInterceptor.invoke(this);
			}
	
			public static void main(String[] args) {
				ReflectiveMethodInvocation mi = new ReflectiveMethodInvocation(new TestFinal());
				//责任链方法执行
				mi.proceed();
				}
		}
		
		执行过程：
		
		>>>>ReflectiveMethodInvocation.proceed()
		
			--->AspectJAfterAdvice.invoke(MethodInvocation methodInvocation)
			
				--->ReflectiveMethodInvocation.proceed()
				
					--->MethodBeforeAdviceInterceptor.invoke(MethodInvocation methodInvocation)
					
						--->MethodBeforeAdviceInterceptor.beforeMethod                          //前置方法
						
						--->ReflectiveMethodInvocation.proceed()
						
							--->target.method()  												 //目标对象方法
		
				--->AspectJAfterAdvice.afterMethod()										     //后置方法
		
		
		
		
		
		
		
		
		
		
		------------ spring boot 启动原理---- 
		一.在context = createApplicationContext(); 构建 org.springframework.context.annotation.AnnotationConfigApplicationContext 对象时，
		   （具体是在AnnotationConfigApplicationContext 默认构造函数中的 new AnnotatedBeanDefinitionReader(this) 中实现）
		   public AnnotationConfigApplicationContext() {
				this.reader = new AnnotatedBeanDefinitionReader(this);
				this.scanner = new ClassPathBeanDefinitionScanner(this);
				}
		   默认向beanfactory注册了以下一些 beandefinitions
			0 = "org.springframework.context.annotation.internalConfigurationAnnotationProcessor"
			1 = "org.springframework.context.annotation.internalAutowiredAnnotationProcessor"
			2 = "org.springframework.context.annotation.internalRequiredAnnotationProcessor"
			3 = "org.springframework.context.annotation.internalCommonAnnotationProcessor"
			4 = "org.springframework.context.event.internalEventListenerProcessor"
			5 = "org.springframework.context.event.internalEventListenerFactory"
		   
		二.分析注册 beandefinition 过程
		invokeBeanFactoryPostProcessors(beanFactory);是注册注解配置的bean的入口
		
		查找beandefinitions中定义的  BeanDefinitionRegistryPostProcessor 
		其中 名称为org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的  
		org.springframework.context.annotation.ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口
		
		于是先创建bean的单例对象，并执行
		ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry 方法 的作用就是解析 带有@Configuration 注解的 beandefinitions  中
			
			@PropertySource
			
			@ComponentScan 
			
			@Import
			
			@Bean
			
			注解
			
		Spring boot 使用 starter 方式启动其他组件，正是由于
		
		@SpringBootApplication 注解 ，包含 @EnableAutoConfiguration 注解 ，包含 @Import({EnableAutoConfigurationImportSelector.class})
		
		而 EnableAutoConfigurationImportSelector 会根据 文件 META/spring.factories 文件，返回需要注册的 bean 对象。
		
		
		
		
		
		
		
		
		
		
		
	
	