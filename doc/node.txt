----------------------maven-----------------------
三个生命周期（lifecycle）       主要阶段（phase）

clean                 pre-clean
                         clean
						 post-clean

default              validate
						compile
						test
						package
						verify
						install
						deploy
						
sit                    pre-site
						site
						post-site



插件的模板与阶段绑定，当执行阶段时，就可以执行插件的目标 goals


mojo 为 一个可执行目标类

每一个类对应一个 goal 比如我们定义一个
---pom.xml
 <groupId>cn.xie</groupId>
  <artifactId>hello-maven-plugin</artifactId>
  <packaging>maven-plugin</packaging>

  
----MyMojo.java
@Mojo(name="hello" ,defaultPhase=LifecyclePhase.CLEAN)
public class MyMojo
    extends AbstractMojo
{
  

    public void execute()
        throws MojoExecutionException
    {
    	System.out.println("hello maven");
    }
}


目标为 hello ，默认绑定的阶段为 clean 阶段


当在其他maven 项目中引入此插件，则会将 hello 绑定到 clean 阶段

-----pom.xml
	<build>
		<plugins>
			<plugin>
				<groupId>cn.xie</groupId>
				<artifactId>hello-maven-plugin</artifactId>
				<version>0.0.1-SNAPSHOT</version>
				<executions>
					<execution>
						<phase>clean</phase>   //绑定的阶段
						<goals>
							<goal>hello</goal>   //绑定 目标
						</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>


单独执行 mvn cn.xie:hello-maven-plugin:0.0.1-SNAPSHOT:hello   可以单独执行目标 

由于插件符合 xxx-maven-plugin 命名规范，可以简化执行 mvn hello:hello  (xxx:goal)

执行 mvn clean （阶段名） 执行绑定在阶段下的所有 goals




<pluginManagement></pluginManagement> 与 
<plugins></plugins>区别
pluginManagement 引入插件管理，只有在子模块使用时才会引入具体插件
plugins 具体的插件配置
举例

在父项目的 pom.xml 引入插件管理

<build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>cn.xie</groupId>
          <artifactId>hello-maven-plugin</artifactId>
          <version>0.0.1-SNAPSHOT</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
  
  
 子模块只需要配置插件以及绑定目标与阶段，不需要指定版本
 
 <build>
		<plugins>
			<plugin>
				<groupId>cn.xie</groupId>
				<artifactId>hello-maven-plugin</artifactId>
				<executions>
					<execution>
						<phase>pre-clean</phase>
						<goals>
							<goal>hello</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
	
	执行 mvn hello:hello 可以单独执行 插件目标
	执行 mvn pre-clean 可以执行阶段


<dependencyManagement></dependencyManagement>
<dependencies></dependencies>

dependencyManagement 为管理的 依赖，一般为父项目配置
dependencies 为子项目的具体依赖，如果父项目有配置

<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
				<version>4.13</version>
			</dependency>
			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>servlet-api</artifactId>
				<version>2.5</version>
			</dependency>
		</dependencies>
	</dependencyManagement>
	
	
	子项目依赖时可以直接
	
	 <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
    </dependency> ，不需要指定版本
	
	
	
	
	
	
	
	
	
	
	
	Sringboot 与maven 整合
	
	1、项目结构以及依赖关系
	mt_boot 父项目，继承 org.springframework.boot ，包含子模块 mt_web、mt_consumer、mt_dao、mt_interface
	
	mt_web------>mt_consumer---->mt_dao
		                                     ---->mt_interface
											 
											 
	----------------------mt_boot:pom.xml----------------------
	<!-- 父依赖 -->
	 <parent>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-parent</artifactId>
         <version>1.5.22.RELEASE</version>
    </parent>
	
	<!-- 子模块-->
	<modules>
		<module>mt_web</module>
		<module>mt_consumer</module>
		<module>mt_interface</module>
		<module>mt_dao</module>
	</modules>
	
	<!-- 所有子模块依赖管理，子模块引入依赖可以不需要配置版本号-->
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
				<version>4.13</version>
			</dependency>
			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>servlet-api</artifactId>
				<version>2.5</version>
			</dependency>
		</dependencies>
	</dependencyManagement>
	
	<!-- 插件管理，子模块引入插件时可以不需要配置版本号和 goal、阶段配置-->
	<pluginManagement>
			<plugins>
				<plugin>
					<groupId>cn.xie</groupId>
					<artifactId>hello-maven-plugin</artifactId>
					<version>0.0.1-SNAPSHOT</version>
				</plugin>
			</plugins>
	</pluginManagement>
	
	
	 
												  
	----------------------mt_web:pom.xml----------------------				
   <!--继承关系-->	
	<parent>
        <artifactId>mt_boot</artifactId>
        <groupId>cn.xie</groupId>
        <version>1.1</version>
    </parent>

  <artifactId>mt_web</artifactId>
  <packaging>war</packaging>
  
  
  <!--模块依赖-->
 <dependencies>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
   <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <scope>test</scope>
    </dependency>
     <dependency>
      <groupId>cn.xie</groupId>
      <artifactId>mt_consumer</artifactId>
      <version>1.1</version>
    </dependency> 
  </dependencies>
  
  ----------------------mt_consumer:pom.xml----------------------				
   <!--继承关系-->	
   <parent>
        <artifactId>mt_boot</artifactId>
        <groupId>cn.xie</groupId>
        <version>1.1</version>
    </parent>

  <artifactId>mt_consumer</artifactId>
  <packaging>jar</packaging>
  
  <!--模块依赖-->
   <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>cn.xie</groupId>
      <artifactId>mt_interface</artifactId>
      <version>1.1</version>
    </dependency>
     <dependency>
      <groupId>cn.xie</groupId>
      <artifactId>mt_dao</artifactId>
      <version>1.1</version>
    </dependency>
     <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
  </dependencies>
	
	//问题1：我们的项目的入口为 mt_web 模块 的web 工程，如果注入其他模块的 bean？
	

   在 mt_web 中如何通过 SpringBoot 注入bean ？
   
   --------------mt_web 中 配置：
   
   @Controller
    public class MchtController {
	
	@Autowired
	private MchtInterface mchtServer;

   ---------------mt_consumer 中 配置：
	
	@Service
    public class MchtInfoReference implements MchtInterface{
	/*
	 2021年2月2日下午4:30:53
	 */
	@Autowired
	private MchtDao mchtDao;
	
	------------mt_dao 中 配置：
	@Repository
   public class MchtDaoImpl implements MchtDao{
	
	
   方式1.可以在启动类手动添加扫描 @ComponentScan(basePackages={"org.mt_consumer","org.mt_dao","org.mt_web"})
   方式2.使用spring boot -starter 的方式
            在 mt_consumer 和 mt_dao 这类外部模块中添加 
			META-INF/spring.factories 文件 
			配置自动配置项  org.springframework.boot.autoconfigure.EnableAutoConfiguration=
			org.mt_consumer.conf.ReferenceConf
			
			--------------------------------------------------------
			 @Configuration
             @EnableConfigurationProperties(HelloProperties.class)
              public class ReferenceConf {
          
	
	         @Autowired
	          HelloProperties  helloProperties;
	
	         @Bean
             public OperInterface operInfo()
               {
		        System.out.println("---------"+helloProperties.getPrefix());
    	        return new  OperInfoReference();
               }

           }
		   -----------------------
		在 mt_web 启动类启动时会自动读取各个依赖包的 META-INF/spring.factories  文件中的 EnableAutoConfiguration 值，注册为 beandefinition 
		
        这里涉及另一个问题：我们的项目的入口为 mt_web 模块 的web 工程，配置文件 application.properties 只有 mt_web 中有，如果其他模块
		mt_consumer 、mt_dao 需要用到配置，如何处理？
		 使用 @EnableConfigurationProperties(HelloProperties.class) 
		 
		 
		 @ConfigurationProperties(prefix="hello")
          public class HelloProperties {

	        private String prefix;
	        private String suffix;
	        public String getPrefix() {
		        return prefix;
	        }
	        public void setPrefix(String prefix) {
		        this.prefix = prefix;
	       }
	       public String getSuffix() {
		        return suffix;
	        }
	      public void setSuffix(String suffix) {
		       this.suffix = suffix;
	        }
          }
		  
		  
		  在配置类中引入 参数类 @EnableConfigurationProperties(HelloProperties.class)
		  当配置类 （@Configuration） 添加到 beandefine 时会将 参数类自动装配成对象 HelloProperties
		
		
















-------内部类------


------------
假定有一个包， cn.yao.test.thread ,（java中包名==目录结构）在src文件夹下
 src/cn.yao.test.thread.TestMain.java;
 src/cn.yao.test.task.MyDaemonThread.java;
 其中TestMain中用到了MyDaemonThread
编译命令：cd src
-----javac -d ../mybin cn/yao/test/thread/TestMain.java
          -d参数为编译class文件路径 ../bin 代表当前目录上级目录的bin目录
          
上面的命令= javac -d ../mybin  -classpath "'" cn/yao/test/thread/TestMain.java
[classpath javac命令的classpath是编译时引入包的路径，比如
：
TestMain 中
import oracle.jdbc.driver.OracleDriver;
引入了Oracle驱动的外部包，
javac -d ../mybin  -classpath "." cn/yao/test/thread/TestMain.java
当编译器执行到
import oracle.jdbc.driver.OracleDriver; 时，编译器会去默认的当前目录找是否有这个包oracle.jdbc.driver.OracleDriver（也就是目录）
E:\lib\ojdbc14.jar 没找到编译不通过，
PS:jar包其实就是文件夹，在引入class文件是只需要指定到文件夹
   指定jar时 需要指定到jar包        -------------重要
比如
javac -d ../mybin  -classpath "E:\lib\" cn/yao/test/thread/TestMain.java
所以需要修改为 
javac -d ../mybin  -classpath "E:\lib\ojdbc14.jar" cn/yao/test/thread/TestMain.java
但是执行还是会有问题
javac -d ../mybin  -classpath "E:\lib\ojdbc14.jar" cn/yao/test/thread/TestMain.java
由于TestMain引入了其他包MyDaemonThread ，在E:\lib\ojdbc14.jar 中找不到，所有需要添加当前目录到classpath
最终的命令（大功告成）-classpath "E:\lib\ojdbc14.jar;."
-----------javac -d ../mybin  -classpath "E:\lib\ojdbc14.jar;." cn/yao/test/thread/TestMain.java
]

java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=d:\test.hprof -cp "."  cn.mt.gc.TestGC
java  -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=d:\test.hprof -cp "."  cn.mt.gc.TestGC


cd ../mybin(原理和javac一样，需要加载外部包和class，所以需要设置classpath)
java -Xms512m -Xmx512m -classpath "E:\lib\ojdbc14.jar;."  cn.yao.test.thread.TestMain

类加载器为null，引导类加载器 加载系统类
          ExtClassLoader 扩展类加载器 加载在jre/lib/ext 下面的扩展类 父加载器为  引导类加载器
          AppClassLoader 系统类加载器 加载应用类 父加载器为  ExtClassLoader
          MyTestClassloader 自定义类加载器 父加载器为  AppClassLoader
          类加载采用双亲委派加载模式，下级加载器默认会调用父加载器的加载方法，只有在父加载器加载失败时才调用子加载器
类加载器继承ClassLoader
例子：
public class CompClass {
	
	public static void main(String[] args) throws IOException
	{
		InputStream in =new FileInputStream(new File("src/cn/yao/test/design/MyKey.class"));
		File file = new File("src/cn/yao/test/design/MyKey.p");
		if(!file.exists())
		{
			file.createNewFile();
		}
		OutputStream out = new FileOutputStream(file);
        
        int tt=0;
		while((tt=in.read())!=-1)
		{
			
			out.write(tt-1);
		}
		out.close();
		in.close();
	}

}
将编译好的类文件加密（每个字节-1），调用自定义加载器加载时先解密，再加载
public class MyTestClassloader extends ClassLoader {
	
    public Class<?> findClass(String name) {
        byte[] b;
		try {
			b = loadClassData(name);
			return defineClass(name, b, 0, b.length);
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
        
    }

    private byte[] loadClassData(String name) throws IOException {
    	String fileNm = name.replace(".", "/");
    	fileNm+=".p";
    	fileNm="bin/"+fileNm;
        InputStream in =new FileInputStream(new File(fileNm));
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int temp =0;
        while((temp=in.read())!=-1)
        {
        	out.write(temp+1);
        }
        in.close();
        return out.toByteArray();
    }



-------------http请求posp---------------
POST /XYFreeMarker/base/login.action?token=1543486888242 HTTP/1.1\r\n    ---------请求行
Host: localhost:8089\r\n                                                 ---------报文头开始
Connection: keep-alive\r\n
Content-Length: 19\r\n                                                             -----报文内容长度
Cache-Control: max-age=0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n
Origin: http://localhost:8089\r\n
Upgrade-Insecure-Requests: 1\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Referer: http://localhost:8089/XYFreeMarker/\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: zh-CN,zh;q=0.8\r\n
Cookie: JSESSIONID=0B532D6434EC3209049ADE2067145892\r\n
\r\n                                                                       ---------空的回车换行代表报文头结束               
username=&password=                                                        -------------报文内容




----------http get请求-------------------
GET /XYFreeMarker/js/jquery-1.8.2.js HTTP/1.1\r\n                                 ---------请求行
Host: localhost:8089\r\n                                                           ---------报文头开始
Connection: keep-alive\r\n
Accept: */*\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36\r\n
Referer: http://localhost:8089/XYFreeMarker/\r\n
Accept-Encoding: gzip, deflate, sdch\r\n
Accept-Language: zh-CN,zh;q=0.8\r\n
Cookie: JSESSIONID=0B532D6434EC3209049ADE2067145892\r\n
\r\n                                                                                ---------空的回车换行代表报文头结束     



---------------socket---------------
当关闭socket.getOutputStream()
      socket.getInputStream(); 当关闭输入、或输出流时，socket将会被关闭（所有关联的流都将被关闭）
      
      
------线程池
Executor 
 ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<Runnable>(3);   ---阻塞队列
ThreadPoolExecutor exe = new ThreadPoolExecutor(4,         //  -------corePoolSize 核心线程大小
				                                                   //核心线程启动后会一直挂起直到有任务到来
				                                                   //如下，启动后线程池启动4个核心线程
                6,                                         //  -------maximumPoolSize 最大线程大小     
                                                                  //当任务队列已满，当前线程小于最大线程时，新增一个线程
                1000,      //  ------- keepAliveTime  果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止
                TimeUnit.MILLISECONDS,        //   ------keepAliveTime 的单位
                queue,                        //   -------阻塞队列
                handler       //  -------超过最大线程的处理策略
                );  
                   
corePoolSize 、maximumPoolSize 、queue之间的关系
预热阶段
1、当当前存在的线程数getPoolSize小于corePoolSize数时，创建线程（获取全局锁）执行
平稳阶段
2、当当前存在的线程数getPoolSize大于或等于corePoolSize数时，将线程加入queue
3、当queue满了之后，当当前存在的线程数getPoolSize小于maximumPoolSize时，创建线程（获取全局锁）执行
4、当queue满了之后，当当前存在的线程数getPoolSize大于或等于maximumPoolSize时，采用ThreadPoolExecutor.AbortPolicy策略处理新线程
(采用这种方式是避免获取全局锁，预热阶段过后所有的新任务都会从2阶段执行)

Executor，执行对象接口，定义了执行任务的对象，Executor将执行任务与调度任务分离，
Executor 接口并没有严格地要求执行是异步的。在最简单的情况下，执行程序可以在调用者的线程中立即运行已提交的任务
ExecutorService 提供了管理终止的方法shutdown() shutdownNow() 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。
                可为跟踪一个或多个异步任务执行状况而生成 Future 的方法 submit() invokeAll() invokeAny()
Future 表示异步计算的结果(为何称为异步，当调用线程执行submit时，立刻给调用线程返回结果对象future，调用线程继续执行，future中有被调用线程执行信息及返回结果，只有当
        被调用线程执行完成后调用线程才能通过get方法获取到返回结果，二者为异步执行)
       比如：Future<String> future
       = executor.submit(new Callable<String>() {
         public String call() {
             Thread.sleep(2000);
             return "success";
         }});
        调用线程会立刻返回Callable执行的结果对象，当调用future.get()方法时，调用线程会阻塞直至获取到执行结果


//关于jvm内存结构
java线程私有：虚拟机栈+本地方法栈+pc（程序计数器）
java线程共有：方法区+堆
----线程私有
虚拟机栈存放线程的方法的栈帧，当有新的方法调用时会入栈，方法返回出栈
本地方法栈与虚拟机栈类似，存放native方法
pc存放当前方法的内存地址
----所有线程共享
方法区存放加载的类，常量池等
堆存放new的对象


执行方法过程
TestThread1 th1 = new TestThread1();
th1.setPara(1);
1.加载class 文件到 方法区
2.分配堆内存空间 给 th1
3.当需要执行 th1.setPara(1); 方法时
  首先从 th1 堆内存中获取到 虚方法表 中对应的 方法地址
  根据方法的定义给线程栈分配一段栈帧，保存了方法所需的所有数据
  （本地变量表保存了方法所需所有的变量的值，包括参数，第一个位置通常为 this（当前对象地址））
  执行方法指令 
  返回
  
  任何一个方法中变量（参数的生命周期都是在方法内），随着方法执行完成，变量也就不复存在
  而对象的生命周期在创建时开始，到jc时销毁，二者的生命周期不一致
  
  
	分析一下一个匿名内部类方法调用方法之外的变量时为何要加final
	public void setPara()
	{
		final Object para= new  Object();
		Runnable run = new Runnable()
		{

			@Override
			public void run() {
				para.toString();
				
			}
			
		};
	}
	
	执行方法setPara() 时，构建了一个局部变量 para ，一个局部变量 run，
	方法执行完，para 不存在，run， 不存在，但是 run 构建的对象还存在，
	如果按照一般方法，将 外部和内部的para作为同一个变量，显然是无法编译的
	//解决方案
	java在编译时，会将 para 对应的地址（如果是简单对象就是具体的值）作为参数传递给 
	内部类的构造函数
	1.new Runnable()其实是执行了   TestThread1$1(cn.xie.SimpleSpring.mutiThread.TestThread1 arg0, java.lang.Object arg1);
	第一个参数为所有内部类构建时传递的外部类的引用
	final synthetic cn.xie.SimpleSpring.mutiThread.TestThread1 this$0;
  
	private final synthetic java.lang.Object val$para;
		
	run 对象保存了这两个引用作为参数
	
	相当于 TestThread1$1 对象拷贝了一份 地址，保存在 TestThread1$1 对象中。
	
	如果 在内部类执行run方法时，我们将 para 赋其他值 ，内部类中的 para = new Object();
	
	而外部的 para 参数还是指向原来的 对象，导致程序理解上相同变量有不同的值，不符合一致性，所以java规定
	
	内部类引用的外部变量需要用 确保不能被修改
	
	2. 普通内部类和匿名内部类一样如果内部类包含外部类的成员变量，可以对其进行赋值修改，
	 因为 内部类构建时传入了外部类的引用，对内部类对外部类成员变量赋值修改其实是修改的外部类对象的成员变量
	 public  class SingleThreadEventExecutor  
	 {
	 private volatile Thread thread;
	 private void doStartThread() {
        assert thread == null;
        executor.execute(new Runnable() {
            @Override
            public void run() {
                thread = Thread.currentThread();
				
	如上，匿名内部类Runnable 对象其实构造的时候 传入了 SingleThreadEventExecutor 对象 SingleThreadEventExecutor.this
	thread = Thread.currentThread(); 
	其实是 调用的 SingleThreadEventExecutor.this.thread = Thread.currentThread();
		
	-------------------- volatile ------------------
	1.volatile 为解决是多线程同步问题，对于方法局部变量，不存在线程同步问题
		（方法的局部变量保存在本地变量表，是线程独占变量，不存在同步问题），所以
		volatile 只能修饰放在公交区域（多个线程都可共享的堆、方法区）中，
		volatile 只能修饰 对象成员变量 ，类的静态成员变量
		
		volatile 理解为易变的，就是表示参数变化的情况下必须马上感知
		
		public class TestThread1 {
	
		int tt = 0;
		public void setPara()
		{
			int para1=tt;
			int para2=tt;
		}
		
		aload_0 [this]
        getfield cn.xie.SimpleSpring.mutiThread.TestThread1.tt : int [12]
        istore_1 [para1]
        aload_0 [this]
        getfield cn.xie.SimpleSpring.mutiThread.TestThread1.tt : int [12]
        istore_2 [para2]
		
		在执行方法 setPara 时，按一般执行过程，两个变量都是从堆内存中取值赋值，
		但是在编译优化和cpu执行优化时，可能会将取值过程变为 para2 从对应线程的缓存中取值
		
		这样，如果其他线程在  int para1=tt; 执行完后，再获取 para2 的值，para2 的值就没有变
		
		volatile int tt = 0;
		volatile 就是保证 每次获取 tt 的值，都是从堆内存中取值（缓存一致性协议）
		
		
		为啥单例对象需要  volatile 限制，防止指令重排序
		
		一般的单例的双重校验锁
	static  volatile TestThread1 th ;
	public static TestThread1 init()
	{
		if(th==null)
			synchronized(TestThread1.class)
			{
				if(th == null)
					th = new TestThread1();
			}
		
		return th;
	}
		
	为何 th 需要设置为  volatile 的,由于执行时为优化，可能进行指令重排序，在 对象还没构建完成时就将th设置了值，
	
	此时其他线程在获取对象时就获取到了一个不完整的对象
	volatile就是为了防止指令重排序，使用volatile 修饰的 变量 th ,针对他的操作指令都不能重新排序
	
	
	------------------线程-------------------
	
	public static void main(String[] args) throws InterruptedException {
		
		Thread th = new Thread(new Runnable(){

			@Override
			public void run() {
				
				
				int i=0;
				
				synchronized(InterapTest.class)
				{
				while(true)
				{
					
					System.out.println(Thread.currentThread().getName()+":"+i++);
					
				}
				}
				
			}
			
		});
		th.setName("HelloThread");
		th.start();
		
		Thread.sleep(1000);
		int i=0;
		synchronized(InterapTest.class)
		{
		while(true)
		{
			
			System.out.println(Thread.currentThread().getName()+":"+i++);
			
		}
		}

	}
	
	1.简单的线程并发模型
	main 线程和 HelloThread 主线程都需要获取类的对象锁（全局锁），由于HelloThread 先获取到，所以一直循环并不释放锁
	此时线程状态为 
	main          ：java.lang.Thread.State: BLOCKED (on object monitor)  阻塞在获取对象监听器
	HelloThread：java.lang.Thread.State: RUNNABLE                             执行
	
	2.  HelloThread :
	synchronized(InterapTest.class)
				{
				while(true)
				{
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName()+":"+i++);
					
				}
				}
				
		main:	
		Thread.sleep(1000);
		synchronized(InterapTest.class)
		{
		while(true)
		{
			
			System.out.println(Thread.currentThread().getName()+":"+i++);
			
		}	
		
		如果将 HelloThread 线程 sleep(1000); HelloThread 不会释放锁，HelloThread 存在两种状态
		
		
		main          ：java.lang.Thread.State: BLOCKED (on object monitor)  阻塞在获取对象监听器
		HelloThread：java.lang.Thread.State: RUNNABLE                             执行状态
							java.lang.Thread.State: TIMED_WAITING (sleeping)     睡眠状态
							
							
	3.使用 对象的 wait 方法
		HelloThread :
	synchronized(InterapTest.class)
				{
					
				try {
					InterapTest.class.wait();
					//InterapTest.class.wait(5000);
				} catch (InterruptedException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				while(true)
				{
					
					System.out.println(Thread.currentThread().getName()+":"+i++);
					
				}
				}
		main ：
		Thread.sleep(1000);
		synchronized(InterapTest.class)
		{
		while(true)
		{
			//	try {
			//		InterapTest.class.wait();
			//		//InterapTest.class.wait(5000);
			//	} catch (InterruptedException e1) {
			//		// TODO Auto-generated catch block
			//		e1.printStackTrace();
			//	}
			System.out.println(Thread.currentThread().getName()+":"+i++);
			
		}	
		
		
		首先 HelloThread 先获取到锁，执行到 InterapTest.class.wait(); 时，马上释放锁（下面的代码都不执行）
		main 获取到锁，开始执行并永远不释放锁。
		
		状态变化
		
		HelloThread :  java.lang.Thread.State: RUNNABLE  ---->  java.lang.Thread.State: WAITING (on object monitor)
		main           :  java.lang.Thread.State: BLOCKED (on object monitor))---->java.lang.Thread.State: RUNNABLE
		
		
		-----------------------------------------------------------------------
		
		如果 main 在获取到 锁后又继续等待 InterapTest.class.wait();
		HelloThread 也在WAITING (on object monitor) ，HelloThread 会运行吗？
		不会，WAITING (on object monitor) 会一直等待在监听器，直到有 notify 、notifyAll 唤醒监听器
		
		
		
		
		如果 HelloThread 使用  InterapTest.class.wait(5000); 等待，则开始状态为
				
		HelloThread:java.lang.Thread.State: RUNNABLE  ----> java.lang.Thread.State: TIMED_WAITING (on object monitor)  ----> java.lang.Thread.State: BLOCKED (on object monitor)	
		
		-----------------------------------------------------------------------
		
		BLOCKED状态标识阻塞，只要能再次获取到锁  HelloThread 还能继续运行
		
		main
		synchronized(Object)
		{
		main操作1
		Object.notify(); 
		main操作2
		}
		
		HelloThread
		synchronized(Object)
		{
		HelloThread操作1
		Object.wait(); 
		HelloThread操作2
		}
		
		//假设 HelloThread 先执行 main 后执行
		//唤醒 一个 对象监视器 （moniter）等待 （wait ）队列中的线程（随机）
		//由于要获取对象监视器，必须先获取对象的监视器（synchronized(Object)） 才能执行notify() 方法
	    //notify() 方法相当于只是将被唤醒线程（HelloThread）的标识从 wait 变为 runnable 状态，等待cpu执行，本身 main 线程并没有释放锁，而是会继续处在 runnable 状态
		//假如 main 线程执行完Object.notify()后，cpu时间片分配给了  HelloThread ，HelloThread 继续执行，但是需要重新获取 Object 对象的监视器
		//此时 main 并没有释放对象的监视器，所以 HelloThread 变成阻塞（BLOCKED）状态 ，直到main 同步方法执行完，才会释放对象的监视器
		//也就是说 notify 方法（notifyAll） 都不会马上释放锁，只是将 锁上wait的 其他线程状态修改了。
		
		---------------------------    notify() 到底是不是随机唤醒	--------------------	
		
		
java version "1.8.0_162"
Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)

在HotSpot 的jre 环境中运行，看下下面这个程序的结果
	for(int i=0;i<10;i++)
		{
		Thread th = new Thread(new Runnable(){
			@Override
			public void run() {
				
				
				System.out.println(Thread.currentThread().getName()+" start");
				synchronized(lock)
				{
					
				try {
					lock.wait();
				} catch (InterruptedException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				
				}
				
				System.out.println(Thread.currentThread().getName()+" end");
				
			}
		});
		th.setName("HelloThead-"+i);
		th.start();
		//循环启动10个线程，
		//每次启动后主线程睡眠，使得 HelloThead-i 线程有充分时间执行到 lock.wait(); 并释放锁
		Thread.sleep(1000);
		}
		
		for(int i=0;i<10;i++)
		{
		synchronized(lock)
		{
			lock.notify();
			
		}
		//main 循环唤醒线程，每次唤醒后都睡眠（在同步代码块之外），保证唤醒的线程能获取到锁并执行
		Thread.sleep(1000);
		}
		
		
		如果notify()  是随机唤醒的，那么 HelloThead-i  end 应该是无序的
		
		真实情况是：
		
HelloThead-0 start
HelloThead-1 start
HelloThead-2 start
HelloThead-3 start
HelloThead-4 start
HelloThead-5 start
HelloThead-6 start
HelloThead-7 start
HelloThead-8 start
HelloThead-9 start

HelloThead-0 end
HelloThead-1 end
HelloThead-2 end
HelloThead-3 end
HelloThead-4 end
HelloThead-5 end
HelloThead-6 end
HelloThead-7 end
HelloThead-8 end
HelloThead-9 end

---------------------但是打印的 end 也是有序的，也就是说，在 hotpot实现的jdk 其实是wait 队列来唤醒的---------------------------
但是这个不能保证有序，在实际情况中线程的执行不可控，也就是说，进入等待队列并不能简单的用 sleep 来控制。
		
	

//struts2 核心功能就是代理对象DefaultActionProxy 代理对象包含Action的信息，具体执行方法对象核心为回调

1.StrutsPrepareAndExecuteFilter单例对象包含ExecuteOperations execute 执行操作实例;
2.ExecuteOperations execute 对象执行executeAction();
3.ExecuteOperations 对象包含分发器实例Dispatcher dispatcher;
4.分发器执行dispatcher.serviceAction(request, response, mapping);
5.serviceAction方法构建action代理对象
          ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
                    namespace, name, method, extraContext, true, false); 
6.DefaultActionProxy 包含执行方法实例ActionInvocation invocation   
7.DefaultActionInvocation 对象包含过滤器链表对象Iterator<InterceptorMapping> interceptors;
                                                ValueStack stack
8.DefaultActionInvocation执行invoke()方法
    if (interceptors.hasNext()) {
                final InterceptorMapping interceptor = interceptors.next();
                String interceptorMsg = "interceptor: " + interceptor.getName();
                UtilTimerStack.push(interceptorMsg);
                try {
                                resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);
                            }
                finally {
                    UtilTimerStack.pop(interceptorMsg);
                }
            } else {
                resultCode = invokeActionOnly();
            }
9.interceptors 执行intercept 再执行DefaultActionInvocation 回调
		System.out.println("invoke intercept"+this.getClass());
		invocation.invoke();
		System.out.println("invoke intercept"+this.getClass());
		return null;


JAVA堆内存模型及回收算法
内存模型

            new generation                     |old generation
---------------------------------------------- |
EDEN region |S0(From survivor)|S1(to survivor) |      
                       


查看内存（jstat -gc sid）
开始分配内存都从新生代EDEN 区分配内存
|-------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                       |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU   YGC     YGCT    FGC    FGCT     GCT     |
|2048.0 2048.0  0.0    0.0   12800.0   2640.5   34304.0      0.0       ?      ?       0    0.000   0      0.000    0.000  |
|-------------------------------------------------------------------------------------------------------------------------|  
当eden区已满，执行一次 minor gc
EDEN region+SN -------- SM 
EDEN与交换器采用复制算法
当eden区满时，会又一次minor gc 将 交换区的其中一个（假设S0） 与eden区中存活的对象复制到另一个交换区（S1）
EDEN region+S0 --------> S1 
当下一次eden满时，执行minor gc会将S0与S1互换
EDEN region+S1 --------> S0 

例子：
  public static 	List<byte[]> a = new ArrayList<byte[]>();
	
	public static void main(String[] args) throws InterruptedException, IOException
	{
		int i = 0;
		InputStream in = System.in;
		Scanner sc  = new Scanner(in);
	    while(i<100)
	    {
	    	if(sc.nextLine().equals("G"))
	    	{
	         System.out.println("分配"+(i+1)*1+"M堆空间");
	         byte[] b = new byte[1024*1024*1];
	       
	         i++;
	         if(i%9==0) a.add(b);          //每9个保留一个
	    	}
		
	    }
	    sc.close();
	    in.close();

	}
启动参数
-Xms128m -Xmx512m
--1.初始（单位：kbyte千字节）
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0    0.0   34944.0   1397.9   87424.0      0.0     12288.0     446.6       0    0.000   0      0.000    0.000        |
|--------------------------------------------------------------------------------------------------------------------------------------|
S0C+S1C+EC+OC=131072k=128m空间 初始值 s0 s1占3.3%;eden占27%;old gen占66.7%
--2.执行一次
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0    0.0   34944.0   2421.9   87424.0      0.0     12288.0     446.6       0    0.000   0      0.000    0.000        |
|--------------------------------------------------------------------------------------------------------------------------------------|
从eden分配了2421.9kb-1397.9kb的空间1024kb 空间（程序分配了1024*1024byte的数组）
--3.再执行31次共分配32此内存
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0    0.0   34944.0   34166.4   87424.0      0.0     12288.0     446.6       0    0.000   0      0.000    0.000       |
|--------------------------------------------------------------------------------------------------------------------------------------|
从eden分配了34166.4-1397.9=32768.5=32*1024kb空间
--4.执行一次，需要分配1024k内存，但是当前eden区空间不足
程序执行一次YGC（采用复制算法，将S0+eden区的存活对象复制到S1，再将S0+eden区的对象回收）
[GC (Allocation Failure) [DefNew: 34166K->3290K(39296K), 0.0072403 secs] 34166K->3290K(126720K), 0.0072891 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 

|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0  3290.1   34944.0   2086.8   87424.0      0.0     12288.0     446.7       1    0.007    0      0.000    0.007      |
|--------------------------------------------------------------------------------------------------------------------------------------|
分析YGC
在gc之前，已经使用的new generation =S1U+EU=0+34166=34166;
在gc之后，已经使用的new generation =S1U+EU=3290+0=3290;  
(Allocation Failure)：触发GC的原因
DefNew: 34166K->3290K(39296K) 
        DefNew表示垃圾收集器名称，DefNew = 在新生代中使用的，单线程，标记复制（mark-copy）,全线暂停(stw)垃圾收集器
        34166K->3290K 表示可用的新生代内存变化
        (39296K) （新生代可用总大小ps：新生代可用内存为S1或S0+EDEN）
        34166K->3290K(126720K)
        总的使用堆内存变化（此时与新生代堆内存变化一致）
        (126720K) 可使用堆内存总大小 S1或S0+EDEN+Old Generation（PS:126720K+S1(4352)=128m）
在执行gc后
S1U 包括从eden区复制的三个1mb的数组3072以及其他对象
EU 包括新分配的1m数组对象以及其他对象
--5.执行一次（YGC：新生代gc次数；FGC：full gc次数）
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0  3290.1   34944.0   3110.8   87424.0      0.0     12288.0     446.7       1    0.007    0      0.000    0.007      |
|--------------------------------------------------------------------------------------------------------------------------------------|
又从eden分配1m空间
--6.执行33次(打印分配65M堆空间)
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0  0.0  3290.1   34944.0  34855.3   87424.0      0.0     12288.0     446.7       1    0.007    0      0.000    0.007      |
|--------------------------------------------------------------------------------------------------------------------------------------|
--7.执行1次,需要分配1024k内存，但是当前eden区空间不足
[GC [DefNew: 38145K->4096K(39296K), 0.0098370 secs] 38145K->7385K(126720K), 0.0098832 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
|--------------------------------------------------------------------------------------------------------------------------------------|
|      Survivor             |   EDEN region   |old generation     |                                                                    |
|S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC         PU         YGC     YGCT    FGC    FGCT     GCT        |
|4352.0 4352.0 4096.0 0     34944.0  1263.0   87424.0      3289.5    12288.0     446.7       2    0.017    0      0.000    0.017       |
|--------------------------------------------------------------------------------------------------------------------------------------|
38145K->4096K：新生代使用内存 EU+S1U=38145K------>S0U+EU 4096K(在列表中的EU为gc后新分配的内存空间)
38145K->7385K：堆内存使用 EU+S1U+OU=38145K------->S0U+EU+OU=7385K (在列表中的EU为gc后新分配的内存空间)
从新生代到老年代执行的是标记算法

--------------------
根据实验，我们得到新生代复制算法过程

1.新对象创建，如果eden区满执行3 否则执行2
2.在eden区分配内存
3.eden满时，会将eden+s0（或s1）中存活的对象复制到S1（或s0）
4.如果待复制的对象大于S1的大小，将S0和eden中部分对象转移到old区
5.如果待复制的对象复制过几次，将对象转移到old区
涉及算法包括，从eden+s0------>S1采用复制算法
       （由于所有新生代对象在一次GC之后大部分都不存在了，存活的对象较少，所以采用复制算法，回收完后不会出现内存碎片）
       
PS:GC日志参数意思
Serial GC (串行GC)
[GC (Allocation Failure) 
     [DefNew: 34166K->3290K(39296K), 0.0072403 secs] 34166K->3290K(126720K), 0.0072891 secs] 
     [Times: user=0.02 sys=0.00, real=0.02 secs] 

Allocation Failure：触发GC原因，由于年轻代没有空间存放新的对象
DefNew：垃圾收集器名称，表示年轻代使用的,单线程的，标记复制算法，全线暂停的垃圾收集器，由于只清理了新生代，为minor GC
Times：user所有垃圾回收线程消耗CPU时间之和
       sys系统调用和系统等待时间
       real真实消耗时间即应用程序暂停时间，单线程为user+sys
-----------------------------------------------------------------------------------
[GC (Allocation Failure) 
      [DefNew: 1706K->850K(19008K), 0.0050459 secs]
      [Tenured:0K->849K(42368K), 0.0088981 secs] 1706K->849K(61376K), 
      [Metaspace: 3581K->3581K(1056768K)], 0.0207205 secs] 
      [Times: user=0.00 sys=0.00, real=0.02 secs]
Tenured:表示老年代使用的，单线程的，标记清除整理算法，全线暂停的垃圾收集器，清理了新生代+老年代+Metaspace区，为FULL gc
Metaspace:Metaspace空间



Parallel GC(并行GC)
[GC (Allocation Failure) 
    [PSYoungGen: 11856K->992K(14848K)] 11856K->1000K(49152K), 0.0068467 secs] 
    [Times: user=0.00 sys=0.00, real=0.02 secs]
PSYoungGen:垃圾收集器名称，表示年轻代使用的，多线程的，标记复制算法，全线暂停的垃圾收集器，由于只清理了新生代，为minor GC
Times：user所有垃圾回收线程消耗CPU时间之和
       sys系统调用和系统等待时间
       real真实消耗时间即应用程序暂停时间，多线程约等于（user+sys）/线程数
------------------------------------------------------------------
[Full GC (Ergonomics) 
    [PSYoungGen: 936K->0K(14848K)] 
    [ParOldGen: 28680K->29520K(34304K)] 29616K->29520K(49152K), [Metaspace: 3581K->3581K(1056768K)], 0.0258767
secs] [Times: user=0.08 sys=0.00, real=0.03 secs]
Ergonomics:触发GC原因，jvm认为此时可以进行一次垃圾回收
ParOldGen：表示老年代使用的,多线程的，标记清除整理算法，全线暂停的垃圾收集器
[Full GC (Allocation Failure) [PSYoungGen: 912K->0K(14848K)] [ParOldGen: 307216K
->103250K(129536K)] 308128K->103250K(144384K), [Metaspace: 3578K->3578K(1056768K
)], 0.0515708 secs] [Times: user=0.06 sys=0.03, real=0.05 secs]

---------------命令
java -Xms20M -Xmx20M -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/test_[pid].hprof  -cp "." cn.xie.vm.TestOOM
-Xms20M 初始堆内存
-Xmx20M 最大堆内存

当前堆内存总大小=s0c+s1c+ec+oc,即交换区s0总大小+s1总大小+eden区总大小+old generation总大小
[GC [DefNew: 38145K->4096K(39296K), 0.0098370 secs] 38145K->7385K(126720K), 0.0098832 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
               n1  -> n2(n3)                           a1->a2(a3)
n1:新生代使用内存大小=s1u(或s0u)+eu (垃圾回收前)
n2:新生代使用内存大小=s0u(或s1u)+eu (垃圾回收后)
n3:新生代总内存大小=s0c(或s1c)+ec
a1:总的堆内存使用大小=n1+ou(垃圾回收前)
a2:总的堆内存使用大小=n2+ou(垃圾回收后)
a3:总的堆内存大小（s0c(s1c)+ec+oc）

SOCKET NIO
SelectionKey:SelectableChannel 在 Selector 中的注册的标记
SelectableChannel:通道
Selector:多路复用选择器

先看下SelectableChannel
当调用register方法时核心源码为
if ((ops & ~validOps()) != 0)             ----检查当前通道是否支持此操作（~validOps()二进制取反）
	    throw new IllegalArgumentException();
	    ....
  SelectionKey k = findKey(sel);       ----尝试从本地寻找指定Selector的SelectionKey 即如果在对应的Selector中已经注册过了，
            if (k != null) {          
                k.interestOps(ops);    --------将SelectionKey的感兴趣操作更新
		k.attach(att);                     --------更新附加信息
            }
	    if (k == null) {                 -----如果在对应的选择器中没有注册过，
		// New registration
		k = ((AbstractSelector)sel).register(this, ops, att);        -----则注册并返回SelectionKey
		addKey(k);                                                   -----将本地SelectionKey数组更新
	    }
            return k;
------------
根据以上代码我们知道，当SelectableChannel在seletor中注册时，分别在SelectableChannel ，Selector中都维护了SelectionKey数组
在Selector中，每一个通道对应一个SelectionKey
在SelectableChannel中，每一个选择器对应一个SelectionKey
同一通道同一选择器只有一个SelectionKey对象，每一个SelectionKey对象都维护了唯一的Selector和SelectableChannel
通过SelectionKey对象的selector()和channel()方法，我们可以获取到对应的选择器和通道
SelectionKey包括了interest 集合的整数和ready 集合的整数
    interest 集合：即selector 下次循环遍历SelectableChannel时检查哪些操作，初始为注册的操作
     ready 集合：某个键的选择器检测到该键的通道已为此类操作准备就绪（即已经准备的操作），初始为0
当select.select()获取检测到已经准备就绪的操作时，interest 集合：为注册的操作，ready 集合为当前检测到的操作
OP_ACCEPT=16 
OP_CONNECT=8 
OP_READ=1 
OP_WRITE=4 
ServerSocketChannel（服务器通道）只支持OP_ACCEPT操作，
通过SelectionKey.OP_ACCEPT|SelectionKey.OP_CONNECT可注册interest 集合


----------------------------
java 安全
系统默认的安全策略文件
D:\Program Files\jdk1.6.0_45\jre\lib\security\java.security

MyApp.policy 自定义安全策略文件
      代码          代码基（可以是class目录基文件夹，可以是jar包）
grant codeBase "file:D:/Program Files/eclipse/workspace/xyTest/bin/" {
		permission java.io.FilePermission "D:/xy/-", "read";
};
grant codeBase "file:E:/lib/dtest.jar" {
		permission java.io.FilePermission "D:/xy/-", "read";
};

grant {
permission java.util.PropertyPermission "java.security.manager", "read"; 
};
启动程序
D:\Program Files\eclipse\workspace\xyTest\bin>java -Djava.security.manager -Djava.security.policy=D:\MyApp.policy -cp "." cn.xie.securty.TestMain


   FileInputStream fis2 = AccessController.doPrivileged(new  PrivilegedAction<FileInputStream>() {
        public FileInputStream run() {
    	   FileInputStream fis = null;
			try {
			   fis = new FileInputStream("D:\\xy\\mchtlist.txt");
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
            return fis;
        }
      });
      
      //权限校验后返回输入流


//假设m1调用m2调用m3，m3调用文件权限检查
java.security.AccessController.checkPermission(new FilePermission("D:\\xy\\mchtlist.txt", "read"));

method stack
----  top
|m3|
|m2|
|m1|
----  button
那么权限的检查是依次询问所有的调用栈是否有权限，m3------->m2------->m1
而当m3使用特权调用时

public class m3 {
	
	public FileInputStream getFile()
	{
		FileInputStream fis2 = null;

	        fis2 = AccessController.doPrivileged(new  PrivilegedAction<FileInputStream>() {
          public FileInputStream run() {
       	   FileInputStream fis = null;
			try {
			   fis = new FileInputStream("D:\\xy\\mchtlist.txt");
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
              return fis;
          }
        });
	       return fis2;
		
	}

}
当m3权限检查成功，则m2，m1不进行权限检查


NETTY3 
1.ChannelFactory cf = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool(), 8);

-----初始化channel工厂，用于获取服务端channel
  private final ChannelSink sink;  //核心属性 通道下沉池
public NioServerSocketChannelFactory(Executor bossExecutor, Executor workerExecutor, int workerCount)
  {
    if (bossExecutor == null)
      throw new NullPointerException("bossExecutor");

    if (workerExecutor == null)
      throw new NullPointerException("workerExecutor");

    if (workerCount <= 0) {
      throw new IllegalArgumentException("workerCount (" + workerCount + ") " + "must be a positive integer.");
    }

    this.bossExecutor = bossExecutor;                      //构造初始化成员变量 bossExecutor，workerExecutor
    this.workerExecutor = workerExecutor;
    this.sink = new NioServerSocketPipelineSink(workerExecutor, workerCount);       //核心 初始化工作池
  }

---------初始化下沉池 
  private final NioWorker[] workers;  //核心属性 工作者数组
  NioServerSocketPipelineSink(Executor workerExecutor, int workerCount)
  {
    this.workers = new NioWorker[workerCount];  //根据工作者个数创建工作者
    for (int i = 0; i < this.workers.length; ++i)
      this.workers[i] = new NioWorker(this.id, i + 1, workerExecutor);    //核心 每个工作者创建一个工作者对象
  }
  
--------初始化工作者对象
class NioWorker  implements Runnable 是一个可执行对象
  NioWorker(int bossId, int id, Executor executor)
  {
    this.bossId = bossId;           //将bossid保存
    this.id = id;                   //标示工作者id
    this.executor = executor;       //保存工作线程池
    
  }
  
  *****NioServerSocketChannelFactory 初始化完成
  1.构建了一个通道工厂，用于获取服务器端通道，维护一个下沉池
  2.构建了下沉池 ，用于管理工作者，维护多个工作者对象（工作池同时负责创建管理者boss对象，后面会用到）
  3.构建了多个可执行工作者对象，用于具体执行多线程工作
  
  
2.ServerBootstrap bootstrap = new ServerBootstrap(cf); // 初始化启动器

public ServerBootstrap(ChannelFactory channelFactory)
  {
    super(channelFactory);
  }  
  
  父类
   private volatile ChannelFactory factory;       //
  protected Bootstrap(ChannelFactory channelFactory)
  {
    setFactory(channelFactory);                //构建一个启动器并维护通道工厂
  }        
  *******初始化完成
  1.将构造的通道工厂维护到启动器中
  
3. ChannelPipeline pipeline= Channels.pipeline();
构建一个工作流对象
  public static ChannelPipeline pipeline()
  {
    return new DefaultChannelPipeline();
  }
  
  DefaultChannelPipeline();工作流对象核心属性
    
  
  private volatile Channel channel;                           //通道对象
  private volatile ChannelSink sink;                          //属性未知 之后分析
  private volatile DefaultChannelHandlerContext head;        //处理器上下文链表 
  private volatile DefaultChannelHandlerContext tail;

  
  
    处理器上下文链表核心属性
   private final class DefaultChannelHandlerContext
  implements ChannelHandlerContext
  {
    volatile DefaultChannelHandlerContext next;         //链表属性
    volatile DefaultChannelHandlerContext prev;
    private final String name;
    private final ChannelHandler handler;              //具体处理器
    private final boolean canHandleUpstream;           //是否处理上行
    private final boolean canHandleDownstream;         //是否处理下行
    private volatile Object attachment;                //附加内容
}


4.pipeline.addLast("u1",new MyUpHandler());

  public synchronized void addLast(String name, ChannelHandler handler) {
    if (this.name2ctx.isEmpty()) {
      init(name, handler);  //如果没有添加过则初始化一个上下文
    } else {
      checkDuplicateName(name);
      DefaultChannelHandlerContext oldTail = this.tail;
      DefaultChannelHandlerContext newTail = new DefaultChannelHandlerContext(this, oldTail, null, name, handler);

      callBeforeAdd(newTail);

      oldTail.next = newTail;
      this.tail = newTail;
      this.name2ctx.put(name, newTail);

      callAfterAdd(newTail);
    }
  }
  
  -----------构建处理器上下文，保存了
    DefaultChannelHandlerContext(, DefaultChannelHandlerContext paramDefaultChannelHandlerContext1, DefaultChannelHandlerContext paramDefaultChannelHandlerContext2, String paramString, ChannelHandler paramChannelHandler)
    {
      if (paramString == null)
        throw new NullPointerException("name");

      if (paramChannelHandler == null)
        throw new NullPointerException("handler");

      this.canHandleUpstream = paramChannelHandler instanceof ChannelUpstreamHandler;  //是否是上行处理器
      this.canHandleDownstream = paramChannelHandler instanceof ChannelDownstreamHandler;   //是否是下行处理器

      if ((!(this.canHandleUpstream)) && (!(this.canHandleDownstream))) {
        throw new IllegalArgumentException("handler must be either " + ChannelUpstreamHandler.class.getName() + " or " + ChannelDownstreamHandler.class.getName() + '.');
      }

      this.prev = paramDefaultChannelHandlerContext1;
      this.next = paramDefaultChannelHandlerContext2;
      this.name = paramString;
      this.handler = paramChannelHandler;
    }


5. bootstrap.setPipeline(pipeline);
此时启动器中维护了一个 ----------ChannelFactory factory; 通道工厂对象
                                           ----------维护了下沉池对象NioServerSocketPipelineSink
                                                                     -------------维护多个NioWorker 工作者对象
                                                                     
                       -----------ChannelPipeline pipeline 工作流对象
                                            ----------一个通道对象channel
                                            ----------一个处理上下文链DefaultChannelHandlerContext
                                                                     -------------一个处理对象ChannelHandler
                                            
                       -----------ChannelPipelineFactory pipelineFactory  工作流工厂，用于创建工作流对象（getPipeline每次创建一个新的处理流）


6.bootstrap.bind(new InetSocketAddress(port));核心代码

public Channel bind(SocketAddress localAddress)
  {
    if (localAddress == null) {
      throw new NullPointerException("localAddress");
    }

    BlockingQueue futureQueue = new LinkedBlockingQueue();       //构建一个阻塞队列

    ChannelHandler binder = new Binder(this, localAddress, futureQueue);         //6.1
    ChannelHandler parentHandler = getParentHandler();                   //获取父处理器

    ChannelPipeline bossPipeline = Channels.pipeline();                   //构建一个管理者处理流
    bossPipeline.addLast("binder", binder);                               //将绑定操作添加到管理者处理流
    if (parentHandler != null) {
      bossPipeline.addLast("userHandler", parentHandler);                 //如果父处理器不为空，则添加到管理者处理流中
    }


//根据当前工厂创建一个通道，够建通道时将当前工厂，构建的处理流，当前工厂的下沉池传给通道
//也就是说每一个通道拥有公共的通道工厂，自己的管道对象，和公共的下沉池对象
    Channel channel = getFactory().newChannel(bossPipeline);              //获取通道工厂并构建一个通道 6.2

    ChannelFuture future = null;
    boolean interrupted = false;
    do
      try {
        future = (ChannelFuture)futureQueue.poll(2147483647L, TimeUnit.SECONDS);
      } catch (InterruptedException e) {
        interrupted = true;
      }
    while (future == null);

    if (interrupted) {
      Thread.currentThread().interrupt();
    }

    future.awaitUninterruptibly();
    if (!(future.isSuccess())) {
      future.getChannel().close().awaitUninterruptibly();
      throw new ChannelException("Failed to bind to: " + localAddress, future.getCause());
    }

    return channel;
  }
  
  6.1 new Binder(this, localAddress, futureQueue); 构建绑定处理对象，是一个upstreamHandler
  
      private final SocketAddress localAddress;
    private final BlockingQueue<ChannelFuture> futureQueue;
    private final Map<String, Object> childOptions = new HashMap();

    Binder(, BlockingQueue<ChannelFuture> localAddress) {
      this.localAddress = localAddress;
      this.futureQueue = futureQueue;
    };
    
     6.2   public ServerSocketChannel newChannel(ChannelPipeline pipeline) {
    return new NioServerSocketChannel(this, pipeline, this.sink);
    
    ----------------构建服务器通道
      NioServerSocketChannel(ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink)
  {
    super(factory, pipeline, sink);                                          //每一个通道维护了公共的通道工厂，创建的处理流对象，并将下沉池对象保存在通道的附加属性中 6.2.1
    try
    {
      this.socket = java.nio.channels.ServerSocketChannel.open();            //创建服务器通道
    } catch (IOException e) {
      throw new ChannelException("Failed to open a server socket.", e);
    }

    try
    {
      this.socket.configureBlocking(false);                               //通道设置为非阻塞
    } catch (IOException e) {
      try {
        this.socket.close();
      } catch (IOException e2) {
        logger.warn("Failed to close a partially initialized socket.", e2);
      }

      throw new ChannelException("Failed to enter non-blocking mode.", e);
    }

    this.config = new DefaultServerSocketChannelConfig(this.socket.socket());           //ChannelConfig保存socket

    Channels.fireChannelOpen(this);                                                     //6.2.2 启动通道
  }
  }
  
  
  6.2.1   构建通道对象
  protected AbstractChannel(Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink)
  {
    this.parent = parent;
    this.factory = factory;
    this.pipeline = pipeline;

    this.id = allocateId(this);

    pipeline.attach(this, sink);
  }
  
    6.2.2   启动通道
  //netty是事件驱动的架构，操作通过发送事件完成
  public static void fireChannelOpen(Channel channel)
  {
    if (channel.getParent() != null) {
      fireChildChannelStateChanged(channel.getParent(), channel);
    }

    //向netty发送打开通道事件
    channel.getPipeline().sendUpstream(new UpstreamChannelStateEvent(channel, ChannelState.OPEN, Boolean.TRUE));  //获取通道的处理流并上行,在此处理流为
                                                                                          // ChannelPipeline bossPipeline = Channels.pipeline(); 
                                                                                          //       bossPipeline中有bind处理对象      
  }
  

  
  
  DefaultChannelPipeline.sendUpstream();
  
  //处理流的上下
    void sendUpstream(DefaultChannelHandlerContext ctx, ChannelEvent e) {
    try {
      ((ChannelUpstreamHandler)ctx.getHandler()).handleUpstream(ctx, e);
    } catch (Throwable t) {
      notifyHandlerException(e, t);
    }
  }
  //启动流程中是调用bind的handleUpstream方法
  核心方法
   channelOpen(ctx, evt);
   
    public void channelOpen(, ChannelStateEvent evt)
    {
      try
      {
        evt.getChannel().getConfig().setPipelineFactory(this.this$0.getPipelineFactory());

        Map allOptions = this.this$0.getOptions();
        Map parentOptions = new HashMap();
        for (Iterator i$ = allOptions.entrySet().iterator(); i$.hasNext(); ) { Map.Entry e = (Map.Entry)i$.next();
          if (((String)e.getKey()).startsWith("child.")) {
            this.childOptions.put(((String)e.getKey()).substring(6), e.getValue());
          }
          else if (!(((String)e.getKey()).equals("pipelineFactory"))) {
            parentOptions.put(e.getKey(), e.getValue());
          }

        }

        evt.getChannel().getConfig().setOptions(parentOptions);
      } finally {
        ctx.sendUpstream(evt);
      }

      boolean finished = this.futureQueue.offer(evt.getChannel().bind(this.localAddress));       //核心代码，绑定端口
      if ((!($assertionsDisabled)) && (!(finished))) throw new AssertionError();
    }
    
   
   boolean finished = this.futureQueue.offer(evt.getChannel().bind(this.localAddress));
   
   Channels.bind(this, localAddress);
   
    channel.getPipeline().sendDownstream(new DownstreamChannelStateEvent(channel, future, ChannelState.BOUND, localAddress));
    
    
    public void sendDownstream(ChannelEvent e) {
    DefaultChannelHandlerContext tail = getActualDownstreamContext(this.tail);              
    if (tail == null)
      try {
        getSink().eventSunk(this, e);         //标示下沉到底了，处理底层的连接
        return;
      } catch (Throwable t) {
        notifyHandlerException(e, t);
        return;
      }


    sendDownstream(tail, e);
  }
  
  //启动服务会执行两步，打开通道与绑定端口
  
//bose类分析 为NioServerSocketPipelineSink 下沉池的内部类，所有的底层socket操作都在NioServerSocketPipelineSink中执行
//bose类是一个可执行对象，包含一个选择器对象与一个服务器通道对象
//初始化时创建选择器对象，传入一个通道对象，并将通道的accept事件注册到选择器中
private final class Boss
  implements Runnable
  {
    private final Selector selector;
    private final NioServerSocketChannel channel;
    //反编译的，默认构造函数有外部类作为第一个参数
    Boss(, NioServerSocketChannel channel)
      throws IOException
    {
      this.channel = channel;

      this.selector = Selector.open();

      boolean registered = false;
      try {
        //注册accept事件到当前通道
        channel.socket.register(this.selector, 16);
        registered = true;
      } finally {
        if (!(registered))
          closeSelector();

      }

      channel.selector = this.selector; 
      } 

    public void run() {  
    //获取当前线程 main reactor
  final Thread currentThread = Thread.currentThread();
  channel.shutdownLock.lock();
  try{
     for(;;)
     {
     try{
       //监听select
        if(selector.select(1000)>0)  
          {
          //监听到有accept事件时，将已选择清空
          selector.selectedKeys().clear();
          }
          //获取连接通道
          SocketChannel acceptedSocket = channel.socket.accept();
          if(acceptedSocket!=null)
          {
            //如果获取到已经连接的通道，分配连接给工作线程 subreactor
            registerAcceptedChannel(acceptedSocket,currentThread);
            
          }
        }
     }
     finally{
         channel.shutdownLock.unlock();
         closeSelect();
          }
    } } 
    private void registerAcceptedChannel(, Thread currentThread) {
    
     ChannelPipeline pipeline;
      try {
      // 通过管道工程创建一个新的管道
      /*
         方法在 Channels中的静态方法构建
             public static ChannelPipelineFactory pipelineFactory(ChannelPipeline pipeline)
                         {
                            return new ChannelPipelineFactory(pipeline) {
                                public ChannelPipeline getPipeline() {
                                 return Channels.pipeline(this.val$pipeline);
                          }
                         };
                       }
                       
             public static ChannelPipeline pipeline(ChannelPipeline pipeline)
                     {
                             //初始化新的管道
                             ChannelPipeline newPipeline = pipeline();
                             //将当前管道的handler添加的新的管道中
                             for (Iterator i$ = pipeline.toMap().entrySet().iterator(); i$.hasNext(); ) { Map.Entry e = (Map.Entry)i$.next();
                             newPipeline.addLast((String)e.getKey(), (ChannelHandler)e.getValue());
                      }
                      return newPipeline;
                    }   
      */
      pipeline = this.channel.getConfig().getPipelineFactory().getPipeline();


        //获取下沉池中的work线程
        NioWorker worker = this.this$0.nextWorker();                                              
        //new NioAcceptedSocketChannel 构建一个新的连接通道,注册到work线程中（分配任务）
        //channelFactory 为公共通道工厂 NioServerSocketChannelFactory
        //pipeline 每个通道构建一个管道
        //this.channel 服务器通道对象
        //this.this$0 是反编译的，实际为外部类对象，即NioServerSocketPipelineSink 公共下沉池对象
        //acceptedSocket 获取的通道对象
        //worker 工作线程
        //currentThread 当前主线程 
        //当构建完连接的通道以后，将通道注册到worker线程中
        //具体操作是，主线程创建一个通道对象并通过main reactor线程向worker对象的注册队列添加注册通道事件
        
        worker.register(new NioAcceptedSocketChannel(this.channel.getFactory(), pipeline, this.channel, this.this$0, acceptedSocket, worker, currentThread), null);
      }
      catch (Exception e)
      {
        NioServerSocketPipelineSink.logger.warn("Failed to initialize an accepted socket.", e);
        try
        {
          acceptedSocket.close();
        } catch (IOException e2) {
          NioServerSocketPipelineSink.logger.warn("Failed to close a partially accepted socket.", e2);
        }
      }
    }

    private void closeSelector()
    {
      this.channel.selector = null;
      try {
        this.selector.close();
      } catch (Exception e) {
        NioServerSocketPipelineSink.logger.warn("Failed to close a selector.", e);
      }
    }
  }
  
  
 //构造连接通道
final class NioAcceptedSocketChannel extends NioSocketChannel
{
  final Thread bossThread;

  //父类属性
    private final Channel parent;
  private final ChannelFactory factory;
  private final ChannelPipeline pipeline;

  NioAcceptedSocketChannel(ChannelFactory factory, ChannelPipeline pipeline, Channel parent, ChannelSink sink, SocketChannel socket, NioWorker worker, Thread bossThread)
  {
    //构建父类
    super(parent, factory, pipeline, sink, socket, worker);

    this.bossThread = bossThread;
    
    //修改当前channel的状态为已建立连接
    setConnected();
    
    //向管道中发送消息
    Channels.fireChannelOpen(this);     //通道打开上行消息
    Channels.fireChannelBound(this, getLocalAddress());           //通道绑定上行消息
    Channels.fireChannelConnected(this, getRemoteAddress());       //通道连接上行消息
  }
}

  }

  protected AbstractChannel(Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink)
  {
    this.parent = parent;
    this.factory = factory;
    this.pipeline = pipeline;

    //设置通道id
    this.id = allocateId(this);

   //将下沉池放入管道的附加信息中
    pipeline.attach(this, sink);
  }


factory：公共的通道工厂，即构建时传的服务器通道工厂对象NioServerSocketChannelFactory
pipeline：每个通道独有的管道对象，为接受连接时创建
parent：父通道，为服务器通道对象NioServerSocketChannel
sink：公共的下沉池对象，为初始化工厂时创建
socket：具体通道对象
worker：工作线程
bossThread：主线程


  final void setConnected() {
    //如果当前通道状态不为ST_CLOSED 关闭
    if (this.state != -1)
      this.state = 2;  则将当前通道的状态设置为ST_CONNECTED 已建立连接
  }

   Channels.fireChannelOpen(this);
    Channels.fireChannelBound(this, getLocalAddress());
    Channels.fireChannelConnected(this, getRemoteAddress());
    
    
     //worker.register分析
      void register(NioSocketChannel channel, ChannelFuture future)
  {
    Selector selector;
    //判断是否是服务器通道
    boolean server = !(channel instanceof NioClientSocketChannel);
    
    //如果不是服务器通道
    Runnable registerTask = new RegisterTask(this, channel, future, server);

    synchronized (this.startStopLock) {
    //如果线程没启动
      if (!(this.started))
      {
        try {
          this.selector = (selector = Selector.open());
        } catch (Throwable t) {
          throw new ChannelException("Failed to create a selector.", t);
        }

        String threadName = ((server) ? "New I/O server worker #" : "New I/O client worker #") + this.bossId + '-' + this.id;

        boolean success = false;
        try {
          DeadLockProofWorker.start(this.executor, new ThreadRenamingRunnable(this, threadName));

          success = true;
        } finally {
          if (!(success))
          {
            try {
              selector.close();
            } catch (Throwable t) {
              logger.warn("Failed to close a selector.", t);
            }
            this.selector = (selector = null);
          }
        }
      }
      //线程启动
      else
      {
        selector = this.selector;
      }

      if ((!($assertionsDisabled)) && (((selector == null) || (!(selector.isOpen()))))) throw new AssertionError();
      //启动标示
      this.started = true;
      //向线程的任务队列添加一个注册任务
      //
      boolean offered = this.registerTaskQueue.offer(registerTask);
      if ((!($assertionsDisabled)) && (!(offered))) throw new AssertionError();
    }

    if (this.wakenUp.compareAndSet(false, true))
      selector.wakeup();
  }
  
  //具体的worker执行过程核心
      processRegisterTaskQueue();   //处理注册队列   工作线程处理主线程注册的通道（如果有）
      processWriteTaskQueue();      //处理写任务队列      
      processSelectedKeys(selector.selectedKeys());       //处理通道的事件
      
      
      直接看具体的通道事件的处理
      OP_READ 0x1  1
      OP_WRITE 0x100   4
      OP_CONNECT 0x1000   8
      OP_ACCEPT  0x10000   16
      
        private void processSelectedKeys(Set<SelectionKey> selectedKeys) throws IOException {
        //遍历已选择键集
    for (Iterator i = selectedKeys.iterator(); i.hasNext(); ) {
      SelectionKey k = (SelectionKey)i.next();
      i.remove();
      try { int readyOps;
        while (true) { readyOps = k.readyOps();
          //当readyOps=0x1时（当前通道读就绪） readyOps & 0x1==0 为false ((readyOps & 0x1) == 0) && (readyOps != 0)) 为false
          //read(k)就会执行 ，其他情况当readyOps=0x1时 readyOps & 0x1==0 为true ,read(k)不会执行
          //具体的read操作
          if ((((readyOps & 0x1) == 0) && (readyOps != 0)) || 
            (read(k)))
            break;

        }

        if ((readyOps & 0x4) != 0)
          writeFromSelectorLoop(k);
      }
      catch (CancelledKeyException e) {
        close(k);
      }

      if (cleanUpCancelledKeys())
        return;
    }
  }
  
  
    //read操作源码
    private boolean read(SelectionKey k) {
    //获取通道
    SocketChannel ch = (SocketChannel)k.channel();
    //获取通道的附带对象NioSocketChannel
    NioSocketChannel channel = (NioSocketChannel)k.attachment();

    ReceiveBufferSizePredictor predictor = channel.getConfig().getReceiveBufferSizePredictor();

    int predictedRecvBufSize = predictor.nextReceiveBufferSize();

    int ret = 0;
    int readBytes = 0;
    boolean failure = true;
    //创建一个ByteBuffer 具体大小之后再看
    ByteBuffer bb = this.recvBufferPool.acquire(predictedRecvBufSize);
    try {
     //循环读取数据到byteBuffer中 readBytes 为当前数据大小
      do { if ((ret = ch.read(bb)) <= 0) break;
        readBytes += ret; }
       //判断缓冲区是否满了
      while (bb.hasRemaining());

      failure = false;
    } catch (ClosedChannelException e) {
    }
    catch (Throwable t) {
      Channels.fireExceptionCaught(channel, t);
    }

    if (readBytes > 0) {
      //反转缓冲区，将限制设置为当前写大小 ridx设置为0
      bb.flip();

      ChannelBufferFactory bufferFactory = channel.getConfig().getBufferFactory();
      //使用byteBuffer构建一个channelBuffer缓冲区
      ChannelBuffer buffer = bufferFactory.getBuffer(readBytes);
      buffer.setBytes(0, bb);
      buffer.writerIndex(readBytes);

      //释放缓冲区
      this.recvBufferPool.release(bb);
      
      //设置上次收到的缓冲区大小
      predictor.previousReceiveBufferSize(readBytes);
      
      //读完后发送一个消息收到的事件给上行处理器
      Channels.fireMessageReceived(channel, buffer);
    } else {
      this.recvBufferPool.release(bb);
    }

    if ((ret < 0) || (failure)) {
      k.cancel();
      close(channel, Channels.succeededFuture(channel));
      return false;
    }

    return true;
  }
  
  //ps 注册的具体流程是
  1.当有连接时，构建一个channel对象，一个pipeLine对象，并通过boss（main reactor） 主线程向worker对象的注册队列添加注册事件  ----相当于主线程分配工作
  2.worker线程在注册完成后（待确认），会启动，启动后会先后查看注册事件队列，写事件队列，然后将获取对应事件的channel对象并处理   ----subreactor相当于处理读写的工作
  
  
  一 构建服务器通道工厂
  ChannelFactory cf = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),
				Executors.newCachedThreadPool(), 8);
	 构建完成后的结构图
	 
	  NioServerSocketChannelFactory 对象用于获取服务器通道对象
	 
	 ---------------------------------------
	 |Executor bossExecutor;主线程池对象，
	 |Executor workerExecutor;工作线程池对象
	 |NioServerSocketPipelineSink sink;下沉池对象
	 |
	 |
	 |function：
	 |-----构建新的通道对象
	 |newChannel(ChannelPipeline pipeline)
	 --------------------------------------
	 
	 
	 NioServerSocketPipelineSink sink      对象用于处理具体底层io
	 --------------------------------------
	 |NioWorker[] workers; 工作者执行对象，初始化时创建多个
	 |
	 |
	 |function：
	 |   ---处理服务端绑定或客户端连接的底层io操作
	 |  eventSunk(ChannelPipeline pipeline, ChannelEvent e)
	 |  ------处理服务器通道
	 |   handleServerSocket(ChannelEvent e)
	 |  ------处理客户端连接
	 |  handleAcceptedSocket(ChannelEvent e)
	 --------------------------------------           
	 
	 
	 NioWorker implements Runnable       具体工作对象，执行具体的操作
	 --------------------------------------
	 |Executor executor;   工作线程池对象所有的工作者都在此线程池允许
	 |boolean started;     是否已经启动 
	 |Selector selector    选择器对象，每一个工作对象都有一个选择器
	 |Queue<Runnable> registerTaskQueue  注册事件队列
	 |Queue<Runnable> writeTaskQueue     写事件队列
	 |
	 |function：
	 |注册通道到当前注册队列
	 |register(NioSocketChannel channel, ChannelFuture future)  
	 |启动线程执行当前任务
	 |run()  
	 --------------------------------------       
	 
	 二 初始化启动器
	 ServerBootstrap bootstrap = new ServerBootstrap(cf); 
	 
	 ServerBootstrap  服务端启动器    
	 --------------------------------------
	 |ChannelFactory factory; 通道工厂
	 |ChannelPipeline pipeline = Channels.pipeline(); 初始化一个默认管道
	 |ChannelPipelineFactory pipelineFactory = Channels.pipelineFactory(this.pipeline);  初始化一个默认管道工厂
	 |
	 --------------------------------------       
	 
	 三 初始化管道
	 ChannelPipeline pipeline= Channels.pipeline();
	 pipeline.addLast("u1",new MyUpHandler());
	 
	  DefaultChannelPipeline默认管道对象
	 ----------------------------------------
	 |Channel channel;通道对象 初始化为null
	 |ChannelSink sink; 下沉池对象 初始化为null
	 |DefaultChannelHandlerContext head; 处理器头
	 |DefaultChannelHandlerContext tail; 处理器尾
	 |function：
	 | 构建处理器上下文并添加到链表
	 | addFirst(String name, ChannelHandler handler)
	 | addLast(String name, ChannelHandler handler)
	 | 从头发送上行处理
	 | sendUpstream(ChannelEvent e) 
	 | 从尾发送下行处理
	 | sendDownstream(ChannelEvent e)
	 -----------------------------------------
	 
	 四 设置管道及管道工厂
	 bootstrap.setPipeline(pipeline);
   此时启动器的管道为设置的的管道对象
   管道工厂为获取设置管道对象的工厂
   
   五 最重要的部分 
   bootstrap.bind(new InetSocketAddress(port));
   绑定操作，按操作流程进行
   1.构建绑定处理器 ChannelHandler binder = new Binder(this, localAddress, futureQueue);
   2.构建服务端管道，ChannelPipeline bossPipeline = Channels.pipeline();
   3.将处理器设置到 bossPipeline管道上
    ChannelPipeline bossPipeline = Channels.pipeline();
    bossPipeline.addLast("binder", binder);
    if (parentHandler != null) {
      bossPipeline.addLast("userHandler", parentHandler);
    }
   4.根据bossPipeline管道构建服务器通道
    Channel channel = getFactory().newChannel(bossPipeline);
    4.1 通过启动器的服务器通道工厂获取新的服务器通道
     public ServerSocketChannel newChannel(ChannelPipeline pipeline) {
    return new NioServerSocketChannel(this, pipeline, this.sink);
  }
  
  NioServerSocketChannel为服务器通道对象
  ----------------------------------
  |ChannelFactory factory; 通道工厂对象
  |ChannelPipeline pipeline;管道对象
  |
  |
  |
  |
  |
  |
  |
  |---------------------------------
   4.2打开socket，设置为非阻塞
   4.3发送打开通道事件
   Channels.fireChannelOpen(NioServerSocketChannel);
   此时：NioServerSocketChannel包含bossPipeline管道 包含binder操作
   fireChannelOpen获取管道并执行上行处理流
   channel.getPipeline().sendUpstream(new UpstreamChannelStateEvent(channel, ChannelState.OPEN, Boolean.TRUE));
   4.4 执行上行处理流会执行binder channelOpen(ctx, evt)处理
   4.5 evt.getChannel().bind(this.localAddress)
   Channels.bind(this, localAddress);
   4.6 具体执行的是channel.getPipeline().sendDownstream(new DownstreamChannelStateEvent(channel, future, ChannelState.BOUND, localAddress));
      此方法同样调用的是bossPipeline管道的下行处理器链
   4.7由于下行处理器无内容，
      if (tail == null)
      try {
        getSink().eventSunk(this, e);
        return;
      } catch (Throwable t) {
        notifyHandlerException(e, t);
        return;
      }
     下沉池相当于下行处理器的最后一步，用于具体的底层io操作，由于是服务端通道，则执行
     Channels.fireChannelBound(channel, channel.getLocalAddress()); //
     
     具体的操作由      DeadLockProofWorker.start(bossExecutor, new ThreadRenamingRunnable(new Boss(this, channel), "New I/O server boss #" + this.id + " (" + channel + ')'));
     boss线程去执行
     Boss 中首先将通道注册到当前选择器的accept事件
    启动线程执行 channel.socket.register(this.selector, 16);  
      以上操作均在主线程中是操作
      
     main线程启动后循环监听select中的accept事件
     main线程中
      如果有连接，注册当前通道到registerAcceptedChannel(acceptedSocket,currentThread);
      worker.register(new NioAcceptedSocketChannel(this.channel.getFactory(), pipeline, this.channel, this.this$0, acceptedSocket, worker, currentThread), null);
     main线程中构建连接通道对象
   
  

启动线程 负责构建ServerBootstrap 启动器，启动器会构建，服务器通道对象NioServerSocketChannel，注册accept事件到boss的selector对象，并启动boss线程监听NioServerSocketChannel对象事件
boss线程 负责监听accept事件，构建连接通道对象NioAcceptedSocketChannel，注册read事件到work的selector对象，并启动work线程监听NioAcceptedSocketChannel对象事件
work线程 负责监听read事件并发送事件到上行流
NioServerSocketPipelineSink服务器下沉池， 管理boss线程与work线程处理具体io操作，包括处理服务器端的bind操作与客户端的写、关闭等操作
         一个channel或serverchannel主动的状态变化（包括服务器的主动绑定、连接通道的写，最终都会通过eventSunk方法处理io）
         
Channels 负责向通道的管道发送具体的事件（读事件上行，写事件下行）
pipeLine 具体的执行上下行的管道，当下行管道执行完成后执行下沉池对象的eventSunk方法处理io
pipeLine 每个channel对象会创建一个pipeline对象 每个pipeline包含多个handler对象，
handler  对象负责处理具体上下行事件，每个handler对象都为单例的，不管创建多少个pipeline对象，每个pipeline对象创建时都使用同一个handler对象构建
            public static ChannelPipeline pipeline(ChannelPipeline pipeline)
             {
               ChannelPipeline newPipeline = pipeline();  //每次构建channel都会构建一个pipeline对象
                for (Iterator i$ = pipeline.toMap().entrySet().iterator(); i$.hasNext(); ) { Map.Entry e = (Map.Entry)i$.next();
                      //pipeline对象中的handler为同一个对象
                     newPipeline.addLast((String)e.getKey(), (ChannelHandler)e.getValue());
                    }
              return newPipeline;
               }
          
//nio的selector相当于监听器，会一直循环监听注册的通道

1.分析class文件
16进制文件
                          
|-u4魔数--| |u4版本号-| 
CA FE BA BE 00 00 00 32 
  |---常量池个数（从1开始 28个程序分配27个 第0个为系统预留）
|---|  
00 1C  

07 00 02    //07 u1代表类或接口的符号引用 00 02 u2代表引用对应的名字在常量池中的索引即为第二个常量

01 00 1B   //01 u1代表utf-8编码的字符串 00 1B u2代表字符串长度27 紧跟着的27位字节长度就是具体的字符串
。。。 。  //常量池的数据结构 第一位为tag标识，后面的数据根据tag不一样各不一样

使用javap -verbose SoSimple 查看class文件的常量池结构如下

public class SoSimple {
      private    double para=999d;
      private String dwd ="testdwd";
      public void get(int j)
      {
    	  int ki = 2;
    	  double mm = 1.0d;
    	  int z=0 ;
      }
      
      public void put()
      {
    	  get(1);
      }
}

const #1 = class        #2;     //  cn/yao/test/thread/SoSimple
const #2 = Asciz        cn/yao/test/thread/SoSimple;
const #3 = class        #4;     //  java/lang/Object
const #4 = Asciz        java/lang/Object;
const #5 = Asciz        para;
const #6 = Asciz        D;
const #7 = Asciz        dwd;
const #8 = Asciz        Ljava/lang/String;;
const #9 = Asciz        <init>;
const #10 = Asciz       ()V;
const #11 = Asciz       Code;
const #12 = Method      #3.#13; //  java/lang/Object."<init>":()V
const #13 = NameAndType #9:#10;//  "<init>":()V
const #14 = double      999.0d;
const #16 = Field       #1.#17; //  cn/yao/test/thread/SoSimple.para:D
const #17 = NameAndType #5:#6;//  para:D
const #18 = String      #19;    //  testdwd
const #19 = Asciz       testdwd;
const #20 = Field       #1.#21; //  cn/yao/test/thread/SoSimple.dwd:Ljava/lang/String;
const #21 = NameAndType #7:#8;//  dwd:Ljava/lang/String;
const #22 = Asciz       LineNumberTable;
const #23 = Asciz       LocalVariableTable;
const #24 = Asciz       this;
const #25 = Asciz       Lcn/yao/test/thread/SoSimple;;
const #26 = Asciz       get;
const #27 = Asciz       (I)V;
const #28 = Asciz       j;
const #29 = Asciz       I;
const #30 = Asciz       ki;
const #31 = Asciz       mm;
const #32 = Asciz       z;
const #33 = Asciz       put;
const #34 = Method      #1.#35; //  cn/yao/test/thread/SoSimple.get:(I)V
const #35 = NameAndType #26:#27;//  get:(I)V
const #36 = Asciz       SourceFile;
const #37 = Asciz       SoSimple.java;

常量池有字面量（基本数据类型常量及final的常量）
 +符号引用（包括类或接口的全限定名，字段名称和描述，方法名称及描述）
 
 #1 为类符号引用，引用了#2
 #2 为字符串 ，值为类的全限定名
 #3 为类符号引用，引用了#4
 #4 为字符串，值为类的全限定名
 #12 为方法符号引用，引用了#3.#13 代表类的引用.方法的描述引用
 #13 为方法描述引用 ，引用了#9:#10;
 #9  为方法名称
 #10 为方法的描述符()V ()代表参数为空，V返回值为空
 #16 为字段名称及描述引用 #1.#17 类的引用.字段名称及描述
 #17 为字段名称及描述引用 #5:#6 名称为#5 类型为#6
 #6  字段类型
 
 在常量池结束后开始定义类的结构（包括类，父类，接口，字段，方法等），
 --------字段描述
 00 21 00 01 00 03 00 00 
 u2:访问标示 00 21 代表acc_public（0001） + acc_super(0020)
 u2:类描述引用 00 01 代表对应常量池#1
 u2:父类描述引用 00 03 代表对应常量池#3
 u2:接口计数器 00 00标示没有实现接口
 
 00 02 00 02 00 05 00 06 00 00 
 u2:字段个数（两个）
 u2:字段访问标示 0002代表private
 u2:名称索引 00 05代表对应常量池#5
 u2:字段描述索引 00 06代表对应常量池#6
 u2:附加信息 00 00 代表为空
 
 00 02 00 07 00 08 00 00 第二个参数描述，与第一个参数一致
 
 -------方法描述
 00 03 00 01 00 09 00 0A 00 01 00 0B
 u2:方法个数 00 03 代表三个
 u2:方法的访问标示 00 01 代表public
 u2:方法的名称索引 #9
 u2:方法的描述索引 #10 ()V，括号代表参数，V代表无返回
 u2:方法的属性信息个数 为一个
 u2:属性信息索引 #11，#11为code，方法的具体字节码放在code属性中
 之后放在的就是code的具体内容( 00 0B接上)
 00 0B 00 00 00 48 00 03 00 01
 u2:属性信息索引 #11，#11为code，方法的具体字节码放在code属性中
 u4:属性值长度：00 00 00 48 代表之后属性值长度为72(属性表长度-6 为当前属性值长度)
 u2:最大操作数栈深度max_stack，为方法运行时分配栈桢时的操作数栈大小00 03代表深度为3
 u2:本地变量表大小max_locals,为方法运行时分配栈桢时的本地变量表大小00 01代表大小为1
    分配的单位为slot，除double与long类型的数据占两个slot外，其他基本数据类型或引用数据类型都占一个slot，
 （这两项在类编译阶段就已经确定了，后续在方法入栈分配内存时按确定的大小分配操作数栈及本地变量表）
 
 00 00 00 12
 u4:字节码长度 这里长度为18位（每一个字节为一个指令）
 
 2A B7 00 0C 2A 14 00 0E B5 00 10 2A 12 12 B5 00 14 B1
 //具体代码执行过程之后分析
 
 00 00 00 02 
 u2:异常表长度 00 00 无
 u2:属性值个数 00 02 两个
 
 -------异常表的作用
 public int tett()
	{
		int x;
		try{
			x=1;
			return x;
		}
		catch(Exception e)
		{
			x=2;
			return x;
		}
		finally
		{
			x=3;
		}
	}
	这样一段代码从字节码分析
	
     0  iconst_1       //int 类型1推至栈顶
     1  istore_1 [x]   //将栈顶int类型的数保存到本地变量表的索引为1的位置x
     2  iload_1 [x]    //将本地变量表1位置的数据推至栈顶
     3  istore 4       //复制栈顶副本到本地变量表4位置   
     5  iconst_3       //int 类型3推至栈顶 finally代码
     6  istore_1 [x]   //将栈顶数据保存到本地变量表的索引为1的位置x
     7  iload 4        //将变量表4位置的数推至栈顶
     9  ireturn        //栈顶推出int数据并返回
    10  astore_2 [e]
    11  iconst_2
    12  istore_1 [x]
    13  iload_1 [x]
    14  istore 4
    16  iconst_3
    17  istore_1 [x]
    18  iload 4
    20  ireturn
    21  astore_3
    22  iconst_3
    23  istore_1 [x]
    24  aload_3
    25  athrow
    
       Exception Table:
        [pc: 0, pc: 5] -> 10 when : java.lang.Exception //当指令在0-5时获取到Exception跳转指令为10
        [pc: 0, pc: 5] -> 21 when : any                //当指令在0-5时获取到其他异常跳转指令为21
        [pc: 10, pc: 16] -> 21 when : any                //当指令在0-5时获取到其他异常跳转指令为21
        
 总之：class文件由类的元数据（包括类，常量，变量，属性，方法的描述）+字节码组成（code，代码）
 
 
 -----------类的加载过程
 1.有且只有四种情况需要立即初始化类
   第一种情况： new 构建对象/ getstatic获取静态值/ putstatic设置静态值/ invokestatic执行静态方法
   ps:final static 常量如果在定义时就已经初始化了，在get时并不会初始化类，应为在编译阶段，get常量已经被
      替换成了具体值
      如果在定义时没有初始化，则在get此常量时需要先初始化类。
   第二种情况: reflect 反射调用时，如果类没有初始化，则先初始化
   第三种情况:初始化类时，如果父类没有初始化，则先初始化父类
   第四种情况：执行main方法的类，即虚拟机程序的入口类
   
  public class SoSimple 
  { 
      public void put()
      {
        LinkObject.getDate();
    	  ImplTest s = new LinkObject();
    	  s.test();
      }
   }
      
      
      
  public class LinkObject
  {
       public static int getDate()
          {
           return 1;
          }
  
      public void test()
         {
           int i=0;
    
          }
  
  }
  
  
  SoSimple.put() 方法的执行过程，
  SoSimple常量池：
const #1 = class        #2;     //  cn/yao/test/thread/SoSimple
const #2 = Asciz        cn/yao/test/thread/SoSimple;
const #3 = class        #4;     //  java/lang/Object
const #4 = Asciz        java/lang/Object;
const #5 = Asciz        para;
const #6 = Asciz        D;
const #7 = Asciz        dwd;
const #8 = Asciz        Ljava/lang/String;;
const #9 = Asciz        <init>;
const #10 = Asciz       ()V;
const #11 = Asciz       Code;
const #12 = Method      #3.#13; //  java/lang/Object."<init>":()V
const #13 = NameAndType #9:#10;//  "<init>":()V
const #14 = double      999.0d;
const #16 = Field       #1.#17; //  cn/yao/test/thread/SoSimple.para:D
const #17 = NameAndType #5:#6;//  para:D
const #18 = String      #19;    //  testdwd
const #19 = Asciz       testdwd;
const #20 = Field       #1.#21; //  cn/yao/test/thread/SoSimple.dwd:Ljava/lang/String;
const #21 = NameAndType #7:#8;//  dwd:Ljava/lang/String;
const #22 = Asciz       LineNumberTable;
const #23 = Asciz       LocalVariableTable;
const #24 = Asciz       this;
const #25 = Asciz       Lcn/yao/test/thread/SoSimple;;
const #26 = Asciz       get;
const #27 = Asciz       (I)V;
const #28 = Asciz       j;
const #29 = Asciz       I;
const #30 = Asciz       ki;
const #31 = Asciz       mm;
const #32 = Asciz       z;
const #33 = Asciz       put;
const #34 = Method      #35.#37;        //  cn/yao/test/thread/SoSimple2.getdate:()I
const #35 = class       #36;    //  cn/yao/test/thread/SoSimple2
const #36 = Asciz       cn/yao/test/thread/SoSimple2;
const #37 = NameAndType #38:#39;//  getdate:()I
const #38 = Asciz       getdate;
const #39 = Asciz       ()I;
const #40 = Method      #35.#13;        //  cn/yao/test/thread/SoSimple2."<init>":()V
const #41 = InterfaceMethod     #42.#44;        //  cn/yao/test/thread/ImplTest.tett:()I
const #42 = class       #43;    //  cn/yao/test/thread/ImplTest
const #43 = Asciz       cn/yao/test/thread/ImplTest;
const #44 = NameAndType #45:#39;//  tett:()I
const #45 = Asciz       tett;
const #46 = Method      #1.#47; //  cn/yao/test/thread/SoSimple.get:(I)V
const #47 = NameAndType #26:#27;//  get:(I)V
const #48 = Asciz       i;
const #49 = Asciz       s;
const #50 = Asciz       Lcn/yao/test/thread/ImplTest;;
const #51 = Asciz       SourceFile;
const #52 = Asciz       SoSimple.java;
 
  0:   invokestatic    #34; //Method cn/yao/test/thread/SoSimple2.getdate:()I
  //执行静态方法，参数为常量#34 
  //#34对应类的符合引用和方法的符号引用
  //执行#35类的符合引用对应类的加载过程，将 #34的符号引用替换为直接引用
  
  3:   istore_1
  4:   new     #35; //class cn/yao/test/thread/SoSimple2
  7:   dup
  8:   invokespecial   #40; //Method cn/yao/test/thread/SoSimple2."<init>":()V
  11:  astore_2
  12:  aload_2
  13:  invokeinterface #41,  1; //InterfaceMethod cn/yao/test/thread/ImplTest.t
tt:()I
  18:  pop
  19:  aload_0
  20:  iconst_1
  21:  invokevirtual   #46; //Method get:(I)V
  24:  return
 LineNumberTable:
  line 15: 0
  line 16: 4
  line 17: 12
  line 18: 19
  line 19: 24

 LocalVariableTable:
  Start  Length  Slot  Name   Signature
  0      25      0    this       Lcn/yao/test/thread/SoSimple;
  4      21      1    i       I
  12      13      2    s       Lcn/yao/test/thread/ImplTest;

      
事务的配置
1.hibernate事务传播行为包括
  PROPAGATION_REQUIED 如果当前没有事务则新建事务 如果有事务，则加入此事务
  POSPConsole系统中配置事务包括
 1 <bean
		class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
		<property name="beanNames">
			<list>
				<value>*Target</value>
				<value>*BO</value>
				<value>*Service</value>
			</list>
		</property>
		<property name="interceptorNames">
			<list>
				<value>transactionInterceptor</value>
			</list>
		</property>
	</bean>
	
	自动为*Target *BO *Service bean 生成事务代理类
	
	2
	<bean id="sy018" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="proxyInterfaces">
			<value>com.huateng.netty.bean.server.base.BaseService</value>
		</property>
		<property name="interceptorNames">
			<list>
				<value>transactionInterceptor</value>
				<value>sy018ServiceTarget</value>
			</list>
		</property>
	</bean>
	
	使用代理工厂bean生成目标对象的事务代理类
	
	
	如果dao和server都存在事务，则dao的事务加入server事务
	事务的回滚只对runtimeException进行回滚，其他Exception不回滚事务
	
	
	
	//简化版的netty线程模型
	 NioSelectorRunnablePool pl = new NioSelectorRunnablePool(boss,worker,2,8);  
	
	 
	 //同时从线程池获取2个boss线程，8个worker线程
	 
	 
	 
	 
	 |----------|               |----------|
	 |          |               |
	 |  boss1   |               |boss2
	 |          |
	 |----------|
	 
	 
	 work1 work2 ... work8
	 
	 每一个线程对应一个选择器对象Selector
	 
	 public void run()
	{
		Thread.currentThread().setName(this.threadNm);
		while(true)
		{
			wakeUp.set(false);
			try {
				select(selector);      //等待选择器监听到通道事件   selector.select();
				processTaskQueue();    //处理当前选择器对象任务队列
				process(selector);     //处理选择器通道
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			
		}
	}
	
	//类设计
	 NioSelectorRunnablePool 用于管理所有的boss和worker对象 有获取boss对象和worker对象的方法
	 Boss ：用于注册ServerChannel对象监听，有registerAcceptChannelTask方法
	 Worker：用于注册Channel对象监听,有registerNewChannelTask方法
	 AbstractNoiSelector：处理选择器的封装对象，有选择，处理任务，处理channel的方法
	 ServerBootStrap：启动器，封装了NioSelectorRunnablePool，包括启动监听方法
	 
	 -------------------------------
	 NioSelectorRunnablePool pl = new NioSelectorRunnablePool(boss,worker,1,2);
	 （注意区分boss对象与boss线程）
	 主线程启动 ，
	   boss线程启动，阻塞在选择器选择操作
	   worker1线程启动 阻塞在选择器选择操作
	   worker2线程启动 阻塞在选择器选择操作
	   
	 主线程获取一个boss对象
	 Boss boss = selectorPool.nextBoss();
	 主线程向 boss对象 加入一个服务器通道任务
	 boss.registerAcceptChannelTask(server);
	 主线程向 boss对象的任务队列中添加一个注册任务，同时唤醒boss对象的选择器
	 registerTask(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					serverChannel.register(selector, SelectionKey.OP_ACCEPT);
				} catch (ClosedChannelException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			
		//主线程唤醒boss对象的选择器，由于boss线程一直阻塞在boss对象选择器的选择方法中，
		    select(selector);      //等待选择器监听到事件  
				processTaskQueue();    //处理当前队列中的注册任务
				process(selector); 
		被唤醒后boss线程开始执行处理任务队列选择器被注册一个通道
		
		
		protected void process(Selector select)throws IOException {
		// TODO Auto-generated method stub
		Set<SelectionKey> selectionKeys = select.selectedKeys();
		if(selectionKeys.isEmpty())
			return ;
		for(SelectionKey key:selectionKeys)
		{
			selectionKeys.remove(key);
			
			ServerSocketChannel severChannel  = (ServerSocketChannel)key.channel();
			
		    SocketChannel channel = severChannel.accept();
		    channel.configureBlocking(false);
		    Worker work = super.getSelectPool().nextWorker(); //从处理队列中取一个
		    work.registerNewChannelTask(channel);
		    System.out.println("一个新的客户端连接");
		}
		
	}
		
		
		
		
		nio？多路复用选择器
		1.SelectableChannel与selector实现多路复用的通道。 
		2.SelectableChannel.regist 向选择器注册通道，返回注册通道的键SelectionKey
		3.SelectionKey键包含通道及事件信息（理解为一个通道与事件的绑定对象）
		4.一个通道至多只能在任意特定选择器上注册一次。也就是说任意selector中最多只包含一个通道对应的键
		5.selector.select()步骤
		  a.将上一次select()到这一次select()期间
		     已取消键集中的每个键(SelectionKey.cancel())从所有键集(selector.keys())中移除（如果该键是键集的成员），并注销其通道
		     （关闭通道会隐式地取消该通道的所有键）此步骤使已取消键集成为空集。
		  b.
		  
		  
		Q1.为什么当我们在服务器通道注册accept事件，但没有Channel.accept方法时会循环获取到accept事件
		    nio的循环问题
		    while(true)
		{
			int tag = select.select();
			System.out.println(tag);
			if(tag>0)
			{
				System.out.println("获取到连接");
			
				Iterator<SelectionKey> iter = select.selectedKeys().iterator();
			    while(iter.hasNext())
				{
			   
			    	SelectionKey key = iter.next();
			    	iter.remove();
			    		if(key.isAcceptable())
			    	{
			    	ServerSocketChannel server = (ServerSocketChannel)key.channel();
			    	//SocketChannel chl = server.accept();
			    	}
				}
				
				if(key.isWritable())
			    	{
			    		SocketChannel chl = (SocketChannel)key.channel();
			    		ByteBuffer buf = ByteBuffer.wrap("byyyby".getBytes());
			    		chl.write(buf.get());
			    		key.cancel();
			    	}
			}
		}
		nio属于水平触发（条件触发）：只要满足条件，就会循环触发事件select;
		SelectionKey.OP_ACCEPT：当前通道没有被获取连接
		SelectionKey.OP_READ：内核缓冲区读不为空
		SelectionKey.OP_WRITE：内核缓冲区没有写满
		所以，当我们没有调用server.accept();一直会触发通道的accept事件
		如果当我们注册了SelectionKey.OP_WRITE事件到通道时，也会循环触发写事件，因为内核缓冲区没有写满条件一直满足，所以只有当有内容需要写时才注册写事件
		写完成后将通道cancel掉，不然会循环的触发写事件
		
		Q2.主线程负责启动boss线程以及worker线程
		启动成功后 boss线程与worker线程阻塞在selector.select()方法
		 之后，主线程向selector注册通道并唤醒阻塞在select()方法的boss线程
		  chl.configureBlocking(false);
			chl.register(selector, SelectionKey.OP_ACCEPT);//主线程向selector注册通道
			this.selector.wakeup();//唤醒阻塞在select()方法的boss线程
			此程序是不能唤醒boss线程的，为什么？
			实验发现：主线程的chl.register(selector, SelectionKey.OP_ACCEPT);会阻塞，唤醒方法并不会执行，
		结论：selector是线程安全的，任何改变键集（publicKeys，selectedKeys,cancelKeys）的方法均是同步的
		这是register方法，在全部键集中加锁
		 synchronized (this.publicKeys) {
      implRegister(localSelectionKeyImpl);
    }
    
    select方法，给selector对象加同步锁
    lockAndDoSelect(long timeOut)
    {
     synchronized (this) {
       if(!isOpen())
       {
       throw new CloseSelectorException();
       synchronized(publicKeys)
        {
          synchronized(publicSelectedKeys)
          {
          return doSelect(timeOut);
          }
        }
       }
      }
    }
    
    由q2，我们引出一个问题：外部线程如何注册时间
    main 线程 wakeup-----------regist
    boss线程  -------wakeuped-----------select
    我们需要确保主线程注册在boss线程选择操作的wakeuped之后，select之前，不然就会获取不到锁而停止执行
    
    Q3.如何确保
    netty使用的方法是，regist操作只将channel放入一个队列里，之后唤醒，唤醒后执行队列里的注册操作，
    流程如下
    main线程   put------wakeup-----------------------------
    boss线程  -----------------wakeuped---poll--------select 


   Q4.对比netty源码分析类的作用
   ServerBootstrap 启动器 
   NioServerSocketChannelFactory 用于生成服务器通道NioServerSocketChannel的工厂
   NioServerSocketChannel：封装了nio的ServerSocketChannel，初始化会打开一个ServerSocketChannel
   ChannelHandlerContext:封装了 NioServerSocketChannel与ChannelPipeline的通道上下文，所有的事件处理都是通过上下文传递
                         每一个通道都对应一个ChannelHandlerContext对象和ChannelPipeline对象
   ChannelPipeline：处理通道的管道对象，每一个通道对应一个管道对象
   ChannelPipelineFactory：生成管道的工厂对象，用于为每个通道生成管道
   ChannelHandler:处理通道方法，为单例，线程不安全ChannelPipeline包含多个ChannelHandler对象
   
   
   主线程初始化启动器时，步骤
   
   1、初始化NioServerSocketChannelFactory 用于生成ServerSocketChannel对象
     1.1、初始化NioServerSocketPipelineSink对象（与handlerPool作用类似）,处理ServerSocketChannel底层操作（包括绑定端口，接收到连接处理）
         1.1.1 初始化多个worker对象，用于处理nioSocketChannel
   2、初始化ChannelPipelineFactory 用于生成ChannelPipeline对象（每个通道对象都对应一个pipeline，所以需要在构建通道对象时通过工厂对象构建Pipeline）

   
   
   
   NioServerSocketPipelineSink：最难理解的对象，
   我们从我们自己的方法中找到他的作用
   我们有一个HandlerPool方法负责处理ServerSocketChannel的各个操作，包括绑定，接收连接
   
public class HandlerPool {
	
	public HandlerPool()
	{

		this.worker = new Worker(this);
	  new Thread(worker).start();
	}
	
	
	public void sunk(Channel channel)
	{
		if(channel instanceof SocketChannel)
		{
		try {

			worker.register((SocketChannel)channel);   //当底层处理请求为SocketChannel时，说明是接收到连接，取出work对象，将通道读事件注册到worker线程的事件队列中
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}
		if(channel instanceof ServerSocketChannel)
		{
		try {
			ServerSocketChannel chl = (ServerSocketChannel)channel;  //如果是server对象，说明是绑定操作绑定端口，并启动boss线程监听boss线程中的通道
			bind(chl,704);
			this.boss = new Boss(this,chl);
			new Thread(this.boss ).start(); 
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}
	
		
	}
	
	public void bind(ServerSocketChannel chl,int port) throws IOException
	{
		chl.configureBlocking(false);
		chl.socket().bind(new InetSocketAddress(port));
		
	}
	

	private Boss boss;
	private Worker worker;
	public Worker getWorker() {
		return worker;
	}
	public void setWorker(Worker worker) {
		this.worker = worker;
	}
	public Boss getBoss() {
		return boss;
	}
	public void setBoss(Boss boss) {
		this.boss = boss;
	}

}

原子性和可见性是线程安全的两个方面,+有序性

synchronized 关键字用于同步操作，可以修改方法，代码块，解决了原子性和可见性的问题，修饰方法获取的是调用方法的实例对象的锁,相当于synchronized(this)
             1.由于synchronized通过获取对象的锁，当不同线程都需要获取同一个对象的锁时，获取到锁的线程继续执行，没获取到的等待，
             所以在synchronize修饰的方法或代码块要么都执行，要么都不执行，每个线程会顺序执行，确保了原子性。
             2.synchronized确保进入同一方法或代码块的线程，都能知道在同一个锁保护之前的任何修改效果，确保一致性
volatile :  只能修饰变量，保证一致性，volatile修饰的任何变量在线程运行的线程栈在读取变量值时都从公共内存（对象堆）中读取
            只能确保可见性，但不能确保原子性
             volatile变量使用场景：
              1.对变量的写操作不依赖于变量的当前值（通常是状态的变化）
              2.改变量没有包含在具有其他变量的不变式子中
Atomic   ： 原子对象可以确保原子性的操作


初始化过程：
 1.初始化NioServerSocketChannelFactory对象
 2.初始化线程池及NioServerSocketPipelineSink对象
 
 
 
 netty 及nio的处理
 
      // 多路复用选择器
      //选择器只是监听通道事件，监听到事件后返回对应的通道及事件
			//具体的io操作由通道完成
			select = Selector.open();
			serverSocketChannel.register(select, SelectionKey.OP_ACCEPT);
			while (true) {
				System.out.println("等待事件");
				select.select();
				System.out.println("有事件进入");
				Set<SelectionKey> set = select.selectedKeys();// 已选择键集
				System.out.println();
				Iterator<SelectionKey> itr = set.iterator(); // 遍历键集
				while (itr.hasNext()) {
					SelectionKey key = itr.next();
           /**
					 * 
					 * 获取事件后移除事件
					 * 从已选择键集中移除
					 * 这里有个问题，当为何要向选择器注册写事件，
					 * 通过实验发现，不注册写事件，也可以向通道内写入数据并发送
					 * 其实注册事件只是将通道注册到选择器中
					 * 注册后选择器可以监听到准备就绪事件的通道
					 * 读事件:是监听当前内核缓冲区是否有可读内容到达，有就返回对应通道
					 * 写事件:是监听当前内核缓冲区是否已经写满，没有满就返回对应通道
					 * 所以读事件只有当有未读内容时才会触发，而写事件如果注册以后会一直触发（因为写缓冲区一般都不满）
					 * 如果不注册读事件，我们可以直接在接收到一个客户端连接后直接读取通道
					 * 如下p1.1 一旦我们获取了通道，我们就能从通道中直接读取数据或写入数据
					 *（非阻塞的，也可以是阻塞的，如果阻塞则需要读取完成才往下执行）
					 * 但读取或写入数据是否成功并不能保证
					 * 因为客户端可能只是连接并没有发送数据
					 * 或者在读取时内核的数据还没有准备好
					 * 这时读到的内容为空
					 * 同样 写入通道同样不需要注册事件，我们可以直接在读取到数据后写入数据
					 * 注册通道事件只是为了监听通道事件就绪并返回对应通道
					 * 获取了通道以后我们可以直接读取、写入并不用注册，但读取写入是否成功不能保证
					 * ---------------------------
					 * 所有触发事件必须处理，否则会循环获取到同一事件
					 * SelectionKey.OP_ACCEPT事件监听serverSocketChannel是否有连接的通道
					 * 如果不serverSocketChannel.accept();下次选择器还会选择到同一个通道连接事件
					 * SelectionKey.OP_READ事件监听SocketChannel是否有可读的数据
					 * 如果不SocketChannel.read(),相当于通道的数据一直未被读取，下次选择器还会选择到同一个读取数据事件
					 * SelectionKey.OP_READ事件监听SocketChannel是否断开连接
					 * 当SocketChannel.read()到数据为-1时，说明客户端已经断开连接，服务器需要key.cancel();tc.close();
					 * 否则下次选择器还会选择到读取数据事件
					*/

					itr.remove();
					if (key.isAcceptable()) {
						System.out.println("有一个客户端连接");
						// 获取到服务器通道
						ServerSocketChannel tc = (ServerSocketChannel) key
								.channel();

						// 获取客户端连接的通道
						SocketChannel ts = tc.accept();
						// 设置通道为非阻塞
						ts.configureBlocking(false);
						// ts.register(select, SelectionKey.OP_READ);

						// P1.1
						// {
						ByteBuffer bb = ByteBuffer.allocate(8);
						ts.read(bb);
						System.out.println(new String(bb.array()));
						// }

					}

					if (key.isReadable()) {
						System.out.println("读取数据");
						// 获取到服务器通道
						SocketChannel tc = (SocketChannel) key.channel();
						ByteBuffer bb = ByteBuffer.allocate(8);
						int ccc = tc.read(bb);
						if(ccc==-1)
						{
							key.cancel();
							tc.close();
						}
						System.out.println(new String(bb.array()));
						try {
							Thread.sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						// P1.1
						// {
						tc.write(ByteBuffer.wrap((new String("hello"))
								.getBytes()));
						// key.cancel();
						// }

					}

					// System.out.println(set.size());
					// else if(key.isReadable())
					// {
					// System.out.println("传输数据");
					// SocketChannel sc = (SocketChannel) key.channel();
					// ByteBuffer bytbuf = ByteBuffer.allocate(1024);
					// bytbuf.clear();
					// sc.read(bytbuf);
					// System.out.println((bytbuf.getChar()));
					// sc.close();
					//
					// }
				}

			}
 
 

    
    
    
     protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
        if (nThreads <= 0) {
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
        }

        if (executor == null) {
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }

        children = new EventExecutor[nThreads];

        for (int i = 0; i < nThreads; i ++) {
            boolean success = false;
            try {
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // TODO: Think about if this is a good exception type
                throw new IllegalStateException("failed to create a child event loop", e);
            } finally {
                if (!success) {
                    for (int j = 0; j < i; j ++) {
                        children[j].shutdownGracefully();
                    }

                    for (int j = 0; j < i; j ++) {
                        EventExecutor e = children[j];
                        try {
                            while (!e.isTerminated()) {
                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                            }
                        } catch (InterruptedException interrupted) {
                            // Let the caller handle the interruption.
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                }
            }
        }

        chooser = chooserFactory.newChooser(children);

        final FutureListener<Object> terminationListener = new FutureListener<Object>() {
            @Override
            public void operationComplete(Future<Object> future) throws Exception {
                if (terminatedChildren.incrementAndGet() == children.length) {
                    terminationFuture.setSuccess(null);
                }
            }
        };

        for (EventExecutor e: children) {
            e.terminationFuture().addListener(terminationListener);
        }

        Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
        Collections.addAll(childrenSet, children);
        readonlyChildren = Collections.unmodifiableSet(childrenSet);
    }
    
    
/*--------------------------------------------------------*/
private final class Boss implements Runnable  ：Boss线程
class NioWorker implements Runnable           : work线程



            bind                 register
main线程---------->启动boss线程------------>启动worker线程
我们想象成三种类型的线程
1.主线程 ，启动ServerBootstrap的线程
2.boss线程，分发acceptChannel的线程
3.work线程，处理Channel的线程



NioServerSocketPipelineSink 可以理解为任何涉及boss线程与worker线程中的底层io操作的入口，
1.当主线程需要绑定一个通道时，bind首先会发送一个上行事件，再发送下行事件，最后发送到NioServerSocketPipelineSink中生成boss对象，启动boss线程，绑定端口
      当





		
	 
	   

//xml文件
<beans xmlns="http://www.springframework.org/schema/beans"  -----默认命名空间，由于beans、bean在默认命名空间，所以不需要加前缀
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    ------xsi命名空间 前缀为xsi
   xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"   -----dubbo命名空间 
   xmlns:mt="http://www.xy.com/schema/mt"                   -----自定义命名空间
   xsi:schemaLocation=                                      -----命名空间xsi的元素 schemaLocation的值    表示命名空间对应的xsd文件的位置
                                                            -----格式： 命名空间 xsd位置                             
          "http://www.springframework.org/schema/beans  classpath:xsd/spring-beans-4.3.xsd
          http://code.alibabatech.com/schema/dubbo classpath:xsd/dubbo.xsd 
          http://www.xy.com/schema/mt http://www.xy.com/schema/mt.xsd">
          
<dubbo:application name="dubbo-demo"/>
<dubbo:registry address="redis://128.160.11.24:6379"/>
<dubbo:protocol name="dubbo" port="20880"/>
<bean id="demoService" class="cn.xy.dubbo.DemoServiceImpl"/>
<dubbo:service interface="cn.xy.dubbo.DemoService" ref="demoService" executes="10"/>
<mt:test id="futest" fut="123"></mt:test>
</beans>

spring自定义标签mt
http://www.xy.com/schema/mt http://www.xy.com/schema/mt.xsd

1.spring加载xml时会根据命名空间去 META-INF/spring.schemas 中寻找对应xsd文件的位置，
  如果找不到，报错，
  
  spring.schemas
      内容:---------http\://www.xy.com/schema/mt.xsd=xsd/mt.xsd
  也可以配置在xsi:schemaLocation 中如：
    http://code.alibabatech.com/schema/dubbo classpath:xsd/dubbo.xsd 
2.spring 根据命名空间去 META-INF/spring.handlers 中寻找处理对应命名空间的方法

  spring.handlers
       内容：---------http\://www.xy.com/schema/mt=cn.xy.cusflag.CusNmspaceHandlers
       
3.CusNmspaceHandlers继承自NamespaceHandlerSupport ，为命名空间处理器
  将对应命名空间绑定一个解析器
  public class CusNmspaceHandlers extends NamespaceHandlerSupport{

	@Override
	public void init() {


		System.out.println(" init cust");
		super.registerBeanDefinitionParser("test", new CusEleParser());
		
	}

}


4.CusEleParser 例子解析器继承自AbstractSingleBeanDefinitionParser 为一个bean的解析器
  public class CusEleParser extends AbstractSingleBeanDefinitionParser{
	

   @Override
protected Class<?> getBeanClass(Element element) {
  //返回的对象类型
	return TestJavaBean.class;
}
   

   @Override
	protected void doParse(Element element, BeanDefinitionBuilder builder) {
		 //对象赋值
	   builder.addPropertyValue("fut",element.getAttribute("fut"));
		
	}
   

}
  
//解析器其他解析器
      mt.xsd
      内容------------
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  
            xmlns="http://www.xy.com/schema/mt"
            targetNamespace="http://www.xy.com/schema/mt">

   

    <xsd:annotation>
        <xsd:documentation>
            <![CDATA[ 测试 ]]></xsd:documentation>
    </xsd:annotation>

  <xsd:element name="test">
        <xsd:complexType>
        <xsd:attribute name="id" type="xsd:string" > </xsd:attribute>
        <xsd:attribute name="fut" type="xsd:string" > </xsd:attribute>
        </xsd:complexType>
  </xsd:element>
   

   

</xsd:schema>

  
/**
 * 自定义spring标签
 * 
 * xmlns:mt="http://www.xy.com/schema/mt"  ----Spring 配置文件添加了自定义命名空间
 * http://www.xy.com/schema/mt http://www.xy.com/schema/mt.xsd"  ---自定义命名空间的schema文件
 * Spring 在META-INF/spring.handlers 文件中找自定义命名空间的处理器
 * Spring 在META-INF/spring.schemas 文件中找自定义命名空间的schema文件路径
 * spring.handlers 
 *        -----http\://www.xy.com/schema/mt=cn.xy.cusflag.CusNmspaceHandlers 
 *            
 * @author Xy
 *
 */
public class CusNmspaceHandlers extends NamespaceHandlerSupport{

	@Override
	public void init() {
        System.out.println("注册元素解析器");
		super.registerBeanDefinitionParser("test", new CusEleParser()); //注册标签的解析器
		
	}

}

public class CusEleParser implements BeanDefinitionParser{

	@Override
	public BeanDefinition parse(Element arg0, ParserContext arg1) {
		// TODO Auto-generated method stub
		  RootBeanDefinition beanDefinition = new RootBeanDefinition();
		  //设置bean初始化对象
	        beanDefinition.setBeanClass(TestJavaBean.class);
	        //将初始化对象注册到上下文
	        arg1.getRegistry().registerBeanDefinition(arg0.getAttribute("id"), beanDefinition);
//          列出所有加载的bean解析器
//	        String[] tr = arg1.getRegistry().getBeanDefinitionNames();
//	        for(String n :tr)
//	        {
//	        	System.out.println(n);
//	        }
	        //设置属性值
	        beanDefinition.getPropertyValues().addPropertyValue("fut", "meme");
	        return beanDefinition;
	}
	

   

}







		
		
	
		






	      	
	      	
-----------netty问题
问题1:当通道对应的work线程阻塞时,心跳包监控线程向通道内写数据无法写入
      原因：netty的work线程负责读写通道(io)
	          在其他线程向通道写数据时最终调用的work对象的writeFromUserCode方法，
	          写操作会先将写事件放入写队列中
	          方法通过  if (scheduleWriteIfNecessary(channel)) {
            判断写操作当前线程是否就是当前work线程，如果是，则立即写写队列中的数据，如果不是，则返回
            
            
            
            


	
	

	总结：
	1. 标签解析
	META-INF/spring.handlers  
		http\://www.xy.com/schema/mt=cn.xy.cusflag.CusNmspaceHandlers
		定义了处理xml标签的具体方法
		
	META-INF/spring.schemas
		http\://www.xy.com/schema/mt.xsd=xsd/mt.xsd 
		定义xsd文件位置
		
	在 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 方法中，通过
	loadBeanDefinitions(beanFactory); 加载 spring.handlers   文件，找到对应的 NamespaceHandlerSupport 方法，
	获取解析器BeanDefinitionParser 构建 BeanDefinition
	
	2. spring-boot-starter  模式
	   META-INF/spring.handlers 配置
	   org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.xie.dubbo.configuration.HelloServiceAutoConfiguration
		
       当SpringApplicationContext.invokeBeanFactoryPostProcessors(beanFactory);
	   时，会通过 名称为 ：
	   org.springframework.context.annotation.internalConfigurationAnnotationProcessor
	   的bean 	org.springframework.context.annotation.ConfigurationClassPostProcessor 
	   方法：
	   postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
			-->processConfigBeanDefinitions(registry);
			
	3. 注解
	
	@Target(ElementType.TYPE) //作用域，ElementType.TYPE 标识接口、类或者注解本身
	@Retention(RetentionPolicy.RUNTIME)    //注解保存策略，RetentionPolicy.SOURCE 源文件保存注解 
											//RetentionPolicy.SOURCE class文件保存
											// RetentionPolicy.RUNTIME 运行时保存
	public @interface Mt {
	
		String[] value() default {};           //参数 （如果注解不输入参数名称，默认是 value）
	
		String[] path() default {};             //参数 default {} 参数默认为空，没有 default {} 该属性值必输

	}
	
	@Mt(value={"11"},key = { "22222" })
	@Mt(value={"11"},key = { "22222" })
	@Mt("11")
   
   
    Class cls 类实现了 AnnotatedElement 接口，继承了 接口中的 default 方法
	
	AnnotatedElementUtils 为spring 提供的 解析 注解的工具类
	
	AnnotatedElementUtils.getMergedAnnotationAttributes(ApplicationStarter.class,  ComponentScan.class);
	//方法可以获取合并的 ComponentScan 注解属性
	
	例子：
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Mt                                        // MtSub 包含 Mt 注解
	public @interface MtSub {
	
		@AliasFor(annotation=Mt.class,attribute="path")  //别名：指向Mt注解的 path 属性
		String[] key();
	
		@AliasFor(annotation=Mt.class,attribute="value")  //别名：指向Mt注解的 value 属性
		String[] value();
    
	}
	
	如果一个注解为
	@MtSub(value={"11"},key = { "22222" })
	我们通过  AnnotationAttributes sub2 = AnnotatedElementUtils.getMergedAnnotationAttributes(TestAnnotation.class,  Mt.class);
	获取到的Mt注解的 属性值为  path：22222 ; value：11
	
	
	@MtSub(value={"11"},key = { "22222" })
	@Mt(value = { "3333333" })
	AnnotationAttributes sub2 = AnnotatedElementUtils.getMergedAnnotationAttributes(TestAnnotation.class,  Mt.class);
	属性值为  path：22222 ; value：3333333   相同属性会覆盖
	
   ---------------------------------------------------------------------------------------------------

	   读取 1. 注解 
	        2. 配置文件中的 org.springframework.boot.autoconfigure.EnableAutoConfiguration  配置的    
			   org.springframework.boot.autoconfigure.EnableAutoConfiguration ，将对应的  cn.xie.dubbo.configuration.HelloServiceAutoConfiguration 
			添加到 beandefinition 中 ，此bean为 配置的bean 
	   
	
	BeanFactoryPostProcessor 在 beandefinition -->bean 之前操作，主要是 改变beanDefinition信息，
	比如增加 注解（@Bean）相关的 beandefinition 、增加 starter （ org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.xie.dubbo.configuration.HelloServiceAutoConfiguration）相关的 beandefinition 
	
	
	
	
	----------------------------------------------------------------
	在执行 SpringApplication.run(ApplicationStarter.class, args); 方法时，
	context = createApplicationContext(); 通过这个方法构建 applicationContext
	Class<?> contextClass = this.applicationContextClass;
		if (contextClass == null) {
			try {
				contextClass = Class.forName(this.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
			}
			catch (ClassNotFoundException ex) {
				throw new IllegalStateException(
						"Unable create a default ApplicationContext, " + "please specify an ApplicationContextClass",
						ex);
			}
		}
		return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);
		
		这里默认的 ApplicationContext是 DEFAULT_CONTEXT_CLASS=org.springframework.context.annotation.AnnotationConfigApplicationContext
	
	
	------------------- AnnotationConfigApplicationContext --------------
	AnnotationConfigApplicationContext 实现 BeanDefinitionRegistry 接口
		包含属性 ：
		
		1. 	AnnotatedBeanDefinitionReader reader;
			用于注解解析为 beandefinition
			在 AnnotatedBeanDefinitionReader 初始化时，会注册如下  Processor
			
				@Configuratrion 注解解析（BeanDefinitionRegistryPostProcessor 、BeanFactoryPostProcessor 接口实现类 ConfigurationClassPostProcessor）
				org.springframework.context.annotation.internalConfigurationAnnotationProcessor
			
				@Autowired 注解解析
				org.springframework.context.annotation.internalAutowiredAnnotationProcessor
			
				@Required 注解解析
				org.springframework.context.annotation.internalRequiredAnnotationProcessor	
			
				org.springframework.context.annotation.internalCommonAnnotationProcessor
				org.springframework.context.event.internalEventListenerProcessor
				org.springframework.context.event.internalEventListenerFactory
			
	    2. 	ClassPathBeanDefinitionScanner scanner;
			包扫描器
		
		3.	DefaultListableBeanFactory beanFactory;
			DefaultListableBeanFactory 也实现了 BeanDefinitionRegistry 接口，
			调用 AnnotationConfigApplicationContext.registerBeanDefinition 方法
			其实是调用 DefaultListableBeanFactory 的 registerBeanDefinition 方法
		
		
		prepareBeanFactory(beanFactory);
		//添加 environment 、systemProperties、systemEnvironment 
		  环境和配置 bean 到 beanFactory 的 singletonObjects 第一缓存中
		  
		postProcessBeanFactory(beanFactory);
		//执行自定义扩展
		
		invokeBeanFactoryPostProcessors(beanFactory);
		//在 之前注册了一个  ConfigurationClassPostProcessor,用于执行 @Configuratrion 注解的解析
		
			----ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()
			
				--->ConfigurationClassPostProcessor.processConfigBeanDefinitions(registry);
				
					--->ConfigurationClassParser parser = new ConfigurationClassParser(
						this.metadataReaderFactory, this.problemReporter, this.environment,
						this.resourceLoader, this.componentScanBeanNameGenerator, registry);
						
					--->ConfigurationClassParser.parse();
					
						--->ConfigurationClassParser.parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
							//传入的是 StandardAnnotationMetadata 对象，此对象封装了 bean 的类信息以及 注解信息
							
							--->ConfigurationClassParser.processConfigurationClass(new ConfigurationClass(metadata, beanName));
							//封装 StandardAnnotationMetadata 与 bean名称 到 ConfigurationClass
							
								--->ConfigurationClassParser.doProcessConfigurationClass(configClass, sourceClass);
									
									--->ConfigurationClassParser.processPropertySource(propertySource); 
										//@PropertySource 解析
										
									--->AnnotationConfigUtils.attributesForRepeatable(
										sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
										//获取 所有的 @ComponentScan 属性
									
									--->ComponentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
										//解析 componentScan 所有属性
										
										--->scanner.doScan(StringUtils.toStringArray(basePackages));
											//扫描包并注册到 beanFactory 的 beanDefinitions 中
							
									---> ConfigurationClassParser.processImports(configClass, sourceClass, getImports(sourceClass), true);
									    // 处理 @Import 标签
										
										---> ConfigurationClassParser.getImports(sourceClass)
											//获取所有的 @Import 标签
											
										--->ConfigurationClassParser.processImports
											//处理 @Import 标签
											//遍历所有的 import 参数值
											--->candidate.isAssignable(ImportSelector.class)
											   //如果 值 为 ImportSelector 接口对象
											
												--->selector.selectImports(currentSourceClass.getMetadata());
													//如果 值 为 ImportSelector 接口对象
													// 调用 selectImports 方法获取 需要导入的类
													// @EnableAutoConfiguration 默认 添加了 @Import(EnableAutoConfigurationImportSelector.class)
													// EnableAutoConfigurationImportSelector 的 selectImports 方法 默认会 查找 
													//META-INF/spring.factories 文件中的 
													// org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项
													// 将其对于的类添加到 beandefinition 中
													// 这就是 各种 xxx-spring-boot-starter 实现原理
											
												---> ConfigurationClassParser.processImports(configClass, currentSourceClass, importSourceClasses, 	false);
												//处理selector 返回的 类 添加到 configClass 中
												
											---> candidate.isAssignable(ImportBeanDefinitionRegistrar.class )
												
												-->ParserStrategyUtils.invokeAwareMethods(
								
												-->configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
													//将 ImportBeanDefinitionRegistrar 对象添加到 configClass 中
												
											---> processConfigurationClass(candidate.asConfigClass(configClass));
											    // 其他的 直接添加到 configClass
												
						---> this.reader.loadBeanDefinitions(configClasses);
							//将所有的 configClasses 加载到 BeanDefinitions 中
							
							--->ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars
								(configClass.getImportBeanDefinitionRegistrars());
								//查 configurationClass 中的 ImportBeanDefinitionRegistrar 对象，并执行 注册方法 registerBeanDefinitions
											
		
		
		-----------xxx-spring-boot-starter 实现原理 ------------
		
		@SpringBootApplication 标注 包含
		@EnableAutoConfiguration 标注 包含
		@Import(EnableAutoConfigurationImportSelector.class)
		在上面的步骤中 
		EnableAutoConfigurationImportSelector.selectImports() 方法会查找 META-INF/spring.factories 文件中的 
		org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项 将其对于的类添加到 beandefinition 中
		
		 
		 ------------- @Import（普通对象）  是一个循环查找的过程----------------------
		 如果 
		 A 启动主类 类有  @Import （B.class）
		 
		 B  类有  @Import （C.class）
		 
		
		1. A 在启动时 添加 到 beandefinitions（ 包含 ：AnnotationMetadata 元数据对象，其中包括注解信息，类的信息） 中 
			ConfigurationClassParser.parse(Set<BeanDefinitionHolder>)   // 参数集合是 A的 BeanDefinitionHolder( BeanDefinition封装类)

		2. 将 A 的元数据封装成一个 ConfigurationClass (配置类)对象，并解析
			ConfigurationClassParser.parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())
			
			--->ConfigurationClassParser.processConfigurationClass(new ConfigurationClass(metadata, beanName));         ←---------------
																																		|		
				--->SourceClass sourceClass = asSourceClass(configClass);  // 将 A 的元数据对象+ A加载的类对象 封装成 SourceClass		|
																																		|	
				---> ConfigurationClassParser.doProcessConfigurationClass(configClass, sourceClass); //执行解析							|
																																		|	
					--->ConfigurationClassParser.processImports(configClass, sourceClass, getImports(sourceClass), true);				|
						//处理 A 中的  @import，获取所有的 Import 类 B																	|		
																															            |		
						--->ConfigurationClassParser.processConfigurationClass(candidate.asConfigClass(configClass));             ------
							//将 B 封装成一个 ConfigurationClass，继续执行 2 步骤中解析过程
							
				--->ConfigurationClassParser.configurationClasses.put(configClass, configClass);
					//解析完成 A ，将 A 添加到 configurationClasses 集合
					// 之后通过 ConfigurationClassBeanDefinitionReader 注册到 beandefinitions 中
					
					
		----------------@Import （ImportBeanDefinitionRegistrar 接口对象）-------------------
		@Import(value={cn.xie.SimpleSpring.registrar.HelloImportBeanDefinitionRegistrar.class})
		流程大致一致，在processImports 中不一样
		
	--->ConfigurationClassParser.parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())
			
			--->ConfigurationClassParser.processConfigurationClass(new ConfigurationClass(metadata, beanName));     
																																				
				--->SourceClass sourceClass = asSourceClass(configClass);  // 将 A 的元数据对象+ A加载的类对象 封装成 SourceClass		
																																			
				---> ConfigurationClassParser.doProcessConfigurationClass(configClass, sourceClass); //执行解析							
																																			
					--->ConfigurationClassParser.processImports(configClass, sourceClass, getImports(sourceClass), true);				
						//处理 A 中的  @import，
						//获取到 Import 类 ImportBeanDefinitionRegistrar																			
																															            		
						---> BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);           
							//实例化 ImportBeanDefinitionRegistrar 对象
							
						---> configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
							//在 A 的 ConfigurationClass 对象中添加 ImportBeanDefinitionRegistrar
							
				--->ConfigurationClassParser.configurationClasses.put(configClass, configClass);
					//解析完成 A ，将 A 添加到 configurationClasses 集合
					
	--->this.reader.loadBeanDefinitions(configClasses);
		// 通过 ConfigurationClassBeanDefinitionReader 注册到 beandefinitions 中	时，
		
		
		--->this.reader.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); 
		   //查询 A 的 configurationClass 中的 ImportBeanDefinitionRegistrar 对象，并执行 注册方法 registerBeanDefinitions
		   
	---> if (registry.getBeanDefinitionCount() > candidateNames.length) 【ConfigurationClassParser】
		---> candidates.add(new BeanDefinitionHolder(bd, candidateName));  
		//检查当前添加的bean是否 大于 候选的 注册的bean
		//如果大于说明还需要检查每一个 注册的 BeanDefinition 是否还需要解析 
		//如果 BeanDefinition 也包含 @Component @ComponentScan @Import @ImportResource 注解 或 @Bean 主键的方法，重复上面的操作
		
		
		
		
		
		
		
		
	
-----------------------------------dubbo 解析-------------------------------------------

1.dubbo spi

Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
System.out.println(protocol);

 以协议接口为例，dubbo使用spi方式获取对象实例，获取的对象为
 com.alibaba.dubbo.rpc.Protocol$Adaptive 
 
ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension() 流程：
---------1. getExtensionLoader获取接口的扩展加载器，如果没有，就new一个
---------2. getAdaptiveExtension 获取动态扩展对象
---------2.1
    public T getAdaptiveExtension() {
       //查看加载器缓存中是否有初始化的动态扩展对象
        Object instance = cachedAdaptiveInstance.get();
        //双重校验锁
        if (instance == null) {
            if (createAdaptiveInstanceError == null) {
                synchronized (cachedAdaptiveInstance) {
                    instance = cachedAdaptiveInstance.get();
                    if (instance == null) {
                        try {
                        // 创建动态扩展对象
                            instance = createAdaptiveExtension();
                            cachedAdaptiveInstance.set(instance);
                        } catch (Throwable t) {
                            createAdaptiveInstanceError = t;
                            throw new IllegalStateException("fail to create adaptive instance: " + t.toString(), t);
                        }
                    }
                }
            } else {
                throw new IllegalStateException("fail to create adaptive instance: " + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);
            }
        }

        return (T) instance;
    }
    
    
---------2.2    
       private T createAdaptiveExtension() {
        try {
             //1.getAdaptiveExtensionClass 获取扩展类
             //2.newInstance实例化扩展类
             //3.injectExtension注入属性
            return injectExtension((T) getAdaptiveExtensionClass().newInstance());
        } catch (Exception e) {
            throw new IllegalStateException("Can not create adaptive extension " + type + ", cause: " + e.getMessage(), e);
        }
    }
    
--------2.3 获取动态扩展类
          private Class<?> getAdaptiveExtensionClass() {
          //获取扩展类
          //1.读取接口对应的文件META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件
          //2.将文件中的key-value放入map
          //3.将map放入缓存对象cachedClasses
             注：cachedClasses = new Holder<Map<String, Class<?>>>();
             holder封装了map，并将map设置为volatile，在设置时使用
             双校验锁，确保同步（volatile 禁用了针对对象内存操作的指令重排序）
              
        getExtensionClasses();
        if (cachedAdaptiveClass != null) {
            return cachedAdaptiveClass;
        }
        //创建
        return cachedAdaptiveClass = createAdaptiveExtensionClass();
    }

--------2.4 创建动态扩展类
        private Class<?> createAdaptiveExtensionClass() {
        //生成动态扩展类代码
        String code = createAdaptiveExtensionClassCode();
        ClassLoader classLoader = findClassLoader();
        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
        return compiler.compile(code, classLoader);
    }



     最终生成的对象为
package com.alibaba.dubbo.rpc;

import com.alibaba.dubbo.common.extension.ExtensionLoader;

public class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {
	public void destroy() {
		throw new UnsupportedOperationException(
				"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!");
	}

	public int getDefaultPort() {
		throw new UnsupportedOperationException(
				"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!");
	}

	public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0,
			com.alibaba.dubbo.common.URL arg1)
			throws com.alibaba.dubbo.rpc.RpcException {
		if (arg1 == null)
			throw new IllegalArgumentException("url == null");
		com.alibaba.dubbo.common.URL url = arg1;
		String extName = (url.getProtocol() == null ? "dubbo" : url
				.getProtocol());
		if (extName == null)
			throw new IllegalStateException(
					"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("
							+ url.toString() + ") use keys([protocol])");
		com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader
				.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class)
				.getExtension(extName);
		return extension.refer(arg0, arg1);
	}

	public com.alibaba.dubbo.rpc.Exporter export(
			com.alibaba.dubbo.rpc.Invoker arg0)
			throws com.alibaba.dubbo.rpc.RpcException {
		if (arg0 == null)
			throw new IllegalArgumentException(
					"com.alibaba.dubbo.rpc.Invoker argument == null");
		if (arg0.getUrl() == null)
			throw new IllegalArgumentException(
					"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null");
		com.alibaba.dubbo.common.URL url = arg0.getUrl();
		String extName = (url.getProtocol() == null ? "dubbo" : url
				.getProtocol());
		if (extName == null)
			throw new IllegalStateException(
					"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("
							+ url.toString() + ") use keys([protocol])");
		com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader
				.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class)
				.getExtension(extName);
		return extension.export(arg0);
	}
}

a.由于extName 为dubbo 对象Protocol$Adaptive 其实就是调用的
   通过ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension("dubbo")获取的对象的方法

b.getExtension("dubbo")通过createExtension("dubbo")获取对象
  //为空则创建
  private T createExtension(String name) {
        Class<?> clazz = getExtensionClasses().get(name);
        if (clazz == null) {
            throw findException(name);
        }
        try {
            T instance = (T) EXTENSION_INSTANCES.get(clazz);
            if (instance == null) {
                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
                instance = (T) EXTENSION_INSTANCES.get(clazz);
            }
            injectExtension(instance);
            //包装类集合
            //包装类通过判断是否有对应类的属性（）
            //比如在加载com.alibaba.dubbo.rpc.Protocol文件时
            //加载了filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper
listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper
mock=com.alibaba.dubbo.rpc.support.MockProtocol
dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol
injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol
rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol
hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol
com.alibaba.dubbo.rpc.protocol.http.HttpProtocol
com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol
thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol
memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol
redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol
rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol
registry=com.alibaba.dubbo.registry.integration.RegistryProtocol
qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper
  
   由于com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper 类中有protocol属性，则为包装类
   
            Set<Class<?>> wrapperClasses = cachedWrapperClasses;
            //这里其实生成
            if (wrapperClasses != null && !wrapperClasses.isEmpty()) {
                for (Class<?> wrapperClass : wrapperClasses) {
                 //包装生成的对象
                 //最初
                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                }
            }
            return instance;
        } catch (Throwable t) {
            throw new IllegalStateException("Extension instance(name: " + name + ", class: " +
                    type + ")  could not be instantiated: " + t.getMessage(), t);
        }
    }




--------2.5 得到对象Protocol$Adaptive的实例后使用injectExtension注入属性


--------2.6 Protocol$Adaptive.export 方法发布服务
         ----code-------
         com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader
				.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class)
				.getExtension(extName);
	      	return extension.export(arg0);
	      	-----code-----
	     调用的extension对象的export方法
	      之前说过， ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);
	      返回的是一个包装对象，
	      按照配置文件META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol 中的配置，生成了一个包装对象
	      ProtocolListenerWrapper
	      包装:QosProtocolWrapper.export(Invoker<T>) line: 60	
        包装:ProtocolFilterWrapper.export(Invoker<T>) line: 100	
        包装:DubboProtocol.export(Invoker<T>) line: 229	


-----dubbo发布服务流程
1.初始化配置参数
<dubbo:application name="dubbo-demo">
<dubbo:parameter key="qos.enable" value="true"/>
<dubbo:parameter key="qos.accept.foreign.ip" value="true"/>
<dubbo:parameter key="qos.port" value="2222"/>
</dubbo:application>
<dubbo:registry address="redis://128.160.11.24:6379"/>
<dubbo:protocol name="dubbo" port="20880"/>
在spring加载配置文件时，初始化了
com.alibaba.dubbo.config.ApplicationConfig
class com.alibaba.dubbo.config.RegistryConfig
com.alibaba.dubbo.config.ProtocolConfig
相关配置的bean，此时dubbo并没有做任何注册、绑定操作
2.发布服务
<dubbo:service interface="cn.xy.dubbo.service.DemoService" ref="demoService" executes="10"/>
具体实现
registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
通过com.alibaba.dubbo.config.spring.ServiceBean 实现服务发布
看下ServiceBean的实例化bean方法,当属性被设置以后，执行发布
 public void afterPropertiesSet() throws Exception {
         ...
        if (!isDelay()) {
            export();
        }
    }


调用ServiceConfig的doExport();方法最终调用的是doExportUrlsFor1Protocol方法
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
                       ...

                        //生成代理对象执行器
                        //具体指cn.xy.dubbo.service.DemoService接口的实现类
                        //interface="cn.xy.dubbo.service.DemoService" ref="demoService"
                        Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
                        //生成代理对象执行器封装对象
                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                        //通过协议的发布方法注册到中间件并发布服务
                        Exporter<?> exporter = protocol.export(wrapperInvoker);
                        exporters.add(exporter);
                        ...
    }

protocol对象通过
ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
实例化



整体流程
1.registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
通过spring配置的<dubbo:service interface="cn.xy.dubbo.service.DemoService" ref="demoService" executes="10"/>
作为发布服务入口
2.com.alibaba.dubbo.config.spring.ServiceBean.afterPropertiesSet() 实例化ServiceBean对象进入发布入口
3.protocol.export(wrapperInvoker); 通过生成动态字节码实例化protocol适配器对象并发布对应接口
4.获取spi对象并生成包装对象WrapperProtocol(包装DubboProtocol )
5.DubboProtocol.createServer(URL url) 启动一个netty服务并绑定端口
  Exchangers.bind(url, requestHandler); 绑定端口与处理器
6.将接口与执行方法保存到DubboProtocol 的exporterMap = new ConcurrentHashMap<String, Exporter<?>>()中
7.当有请求到端口时，通过netty上行处理器获取不同的方法并执行
8.返回信息通过netty下行处理器处理并返回



-------------SpringBoot @EnableDubbo 标注启动dubbo -----

	一共注册的BeanDefinition 包括
	
	com.alibaba.dubbo.config.ApplicationConfig#0
	com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#0
	namePropertyDefaultValueDubboConfigBeanCustomizer
	com.alibaba.dubbo.config.RegistryConfig#0
	com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#1
	com.alibaba.dubbo.config.ProtocolConfig#0
	com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#2
	helloServiceImpl
	providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService

	一、@EnableDubbo(scanBasePackages="cn.xie.SimpleSpring.dubbo.service")
		包含 @EnableDubboConfig 标注 ，包含 @Import(DubboConfigConfigurationRegistrar.class)
		
	二、DubboConfigConfigurationRegistrar 实现了接口 ImportBeanDefinitionRegistrar
		通过 registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) 方法
		向 beanFactory 注册 beandefinition 
		
		registerBeans(registry, DubboConfigConfiguration.Single.class);
		
		dubboConfigConfiguration.Single 注册到 beandefinition
		
	三、spring 会遍历所有的 beanDefinition 是否含有 @Component @ComponentScan @Import @ImportResource 标注，
		解析 dubboConfigConfiguration.Single 标注
		
		  @EnableDubboConfigBindings({
            @EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class)
		})
		public static class Single {

		}
		
	四、@EnableDubboConfigBindings 标注 包含 @Import(DubboConfigBindingsRegistrar.class) 
		DubboConfigBindingsRegistrar 实现了 ImportBeanDefinitionRegistrar
		通过 registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) 方法
		向 beanFactory 注册 beandefinition 
		
		
		DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();
		//构建一个 registrar 对象
        registrar.setEnvironment(environment);

        for (AnnotationAttributes element : annotationAttributes) {

            registrar.registerBeanDefinitions(element, registry);
			//通过 registrar 向 registry 注册 element 

        }
		
		
		 DubboConfigBindingRegistrar.registerBeanDefinitions(element, registry);
		 
			---> DubboConfigBindingRegistrar.registerDubboConfigBeans(prefix, configClass, multiple, registry);
				//prefix 前缀  configClass 注册类 multiple false 
				//检查 配置文件 (application.yml ) 是否包含 前缀 prefix
				
				--->registerDubboConfigBean(beanName, configClass, registry);
					//注册 ApplicationConfig.class 到 beanDefinition 
					//名称为 com.alibaba.dubbo.config.ApplicationConfig#0

				--->registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);
					//注册一个  DubboConfigBindingBeanPostProcessor 到 beanDefinition
					//builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);
					//将 actualPrefix（dubbo.application） 、beanName （dubbo.application）
					//两个 DubboConfigBindingBeanPostProcessor 构造方法的保存到 beanDefinition 中
					//我理解这个 DubboConfigBindingBeanPostProcessor 为了 
					//初始化 ApplicationConfig bean 时给  设置参数值用的
					//回顾bean 实例化过程，在 ApplicationConfig bean 实例化之后，
					// 会执行 DubboConfigBindingBeanPostProcessor 的接口 方法 BeanPostProcessor
					
				---> registerDubboConfigBeanCustomizers(registry);
					// 注册一个 名称为 namePropertyDefaultValueDubboConfigBeanCustomizer 
					// type 为 NamePropertyDefaultValueDubboConfigBeanCustomizer 
					//的beanDefinition
					
					
		此时  @EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class), 注解包含的
		beanDefinition 包括
				com.alibaba.dubbo.config.ApplicationConfig#0 --- ApplicationConfig.class
				**.DubboConfigBindingBeanPostProcessor#0  --- DubboConfigBindingBeanPostProcessor
				namePropertyDefaultValueDubboConfigBeanCustomizer --- NamePropertyDefaultValueDubboConfigBeanCustomizer
		三个bean 注册完成
		
	五、同样的方式，注册其他注解
		@EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class),
			//配置文件没有相关前缀，不注册
		
        @EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class),
			//由于之前注册过 namePropertyDefaultValueDubboConfigBeanCustomizer，
			//不再注册 namePropertyDefaultValueDubboConfigBeanCustomizer 的 beanDefinition 
			// 包含2个 beanDefinition
				com.alibaba.dubbo.config.RegistryConfig#0 --- RegistryConfig
				DubboConfigBindingBeanPostProcessor#1    --- DubboConfigBindingBeanPostProcessor
			
			
        @EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class),
			// 一样
			// com.alibaba.dubbo.config.ProtocolConfig#0 --- ProtocolConfig
			// DubboConfigBindingBeanPostProcessor#2 --- DubboConfigBindingBeanPostProcessor
			
         @EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class),
         @EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class),
         @EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class)
			//配置文件没有相关前缀，不注册    		
					
					
	六、@EnableDubbo(scanBasePackages="cn.xie.SimpleSpring.dubbo.service")
		包含第二个标注 @DubboComponentScan 包含 @Import(DubboComponentScanRegistrar.class) 
		这个标注用来扫描 dubbo 组件
		
		需要执行 DubboComponentScanRegistrar.registerBeanDefinitions() 方法注册 beandefinition
		
	七、以@Service 标注为例
		
		registerServiceAnnotationBeanPostProcessor(packagesToScan, registry)
		
			---> BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);
			---> builder.addConstructorArgValue(packagesToScan);
			---> BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);
			
			//这里其实只是注册了一个 ServiceAnnotationBeanPostProcessor 的beanDefinition 并设置了初始化值
			//packagesToScan = cn.xie.SimpleSpring.dubbo.service
			//最终解析 @Service 标注交给了 ServiceAnnotationBeanPostProcessor
			//ServiceAnnotationBeanPostProcessor 是一个 BeanDefinitionRegistryPostProcessor 接口实现
			//BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry 方法
			// 在 bean 实例化之前，也就是 处理 beanDefinition信息 包括，
			//  更新（新增、修改、删除） beanDefinition 的信息，以便之后的 beanDefinition 实例化、初始化等过程
			
			-----------------------------------------回顾之前的流程-------------------------------------------
			Import（A.class）
			public class ApplicationStarter
			
			
			AnnotationConfigApplicationContext.refresh()
			---> AnnotationConfigApplicationContext.invokeBeanFactoryPostProcessors(beanFactory);
				--->PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
					--->ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()
						1.遍历所有的 beandefinition ，查找 带有 
						 	@Configuration (FullConfiguration) 全配置类 beandefinition
						 	@Component 、@ComponentScan 、@Import、@ImportResource  （LiteConfiguration） 轻量配置类 beandefinition
							@Bean 注解方法 （LiteConfiguration） 轻量配置类 beandefinition
						2.一般为 ConfigurableApplicationContext context =SpringApplication.run(ApplicationStarter.class, args) run 参数的类
						3.解析配置类 ApplicationStarter 的 beandefinition 标注元数据 AnnotationMetadata
						   processConfigurationClass(new ConfigurationClass(metadata, beanName));
						   
						4.ConfigurationClassParser.doProcessConfigurationClass()
							4.1 处理 @PropertySource 标注
							4.2 处理 @ComponentScan 标注
							4.3 处理 @Import（A.class） 标注 
							
								a.	如果 A.class 是 普通类，把 A 当做  ConfigurationClass
									递归执行 processConfigurationClass(new ConfigurationClass());
									将解析的 ConfigurationClass 添加到 ConfigurationClassPostProcessor.configurationClasses 的map 集合中
								
								b.	如果 A.class 是 ImportSelector 实现类 ，
									获取 ImportSelector.selectImports() 返回的 字符数组 
									递归解析 processImports(configClass, currentSourceClass, importSourceClasses, false);
									将解析的 ConfigurationClass 添加到 ConfigurationClassPostProcessor.configurationClasses 的map 集合中
									
								c.	如果 A.class 是 ImportBeanDefinitionRegistrar 实现类，
									添加一个 此对象 到  ApplicationStarter 的BeanDefinition 的 importBeanDefinitionRegistrars 的Map 集合中
									
						5.this.reader.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); 
							//查询 A 的 configurationClass 中的 ImportBeanDefinitionRegistrar 对象，并执行 注册方法 registerBeanDefinitions
		   
						6.if (registry.getBeanDefinitionCount() > candidateNames.length) 【ConfigurationClassParser】
							candidates.add(new BeanDefinitionHolder(bd, candidateName));  
							//检查当前添加的bean是否 大于 候选的 注册的bean
							//如果大于说明还需要检查每一个 注册的 BeanDefinition 是否还需要解析 
							//如果 BeanDefinition 也包含 @Component @ComponentScan @Import @ImportResource 注解 
							//或 @Bean 主键的方法，重复上面的操作			

							

			@Service
			public class HelloServiceImpl	
			
			执行完之前的流程后，需要执行 ServiceAnnotationBeanPostProcessor 的	postProcessBeanDefinitionRegistry方法
			
			ServiceAnnotationBeanPostProcessor.postProcessBeanDefinitionRegistry()
			
				---> ServiceAnnotationBeanPostProcessor.registerServiceBeans(resolvedPackagesToScan,registry);
				
					---> DubboClassPathBeanDefinitionScanner scanner =
							new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);
						//新建一个扫描器
						
					--->scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class));
						//添加 包含的注解过滤器
				
					--->DubboClassPathBeanDefinitionScanner.scan(packageToScan);
						//扫描@EnableDubbo(scanBasePackages="cn.xie.SimpleSpring.dubbo.service") 包中的  @Service 标注
						
						--->DubboClassPathBeanDefinitionScanner.doScan(String...)
							//具体扫描方法，解析 @Service
									
							--->DubboClassPathBeanDefinitionScanner.registerBeanDefinition(definitionHolder, this.registry);
											//注册 @Service 标注的类 beanDefinition
											// 名称：helloServiceImpl 类：HelloServiceImpl
						
					--->ServiceAnnotationBeanPostProcessor.registerServiceBean(beanDefinitionHolder, registry, scanner)
						//注册Service(名称：helloServiceImpl) 暴露的bean
					
						--->AbstractBeanDefinition serviceBeanDefinition =
									buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);
							//构建一个 暴露的 beanDefinition 
							
							--->BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);
								//构建一个 ServiceBean 类的 BeanDefinition
								
							--->ServiceAnnotationBeanPostProcessor.addPropertyReference(builder, "ref", annotatedServiceBeanName);
								// 设置 beanDefinition 的 ref参数 名称：helloServiceImpl 的 bean
								
							---> builder.addPropertyValue("interface", interfaceClass.getName());
								// 设置 beanDefinition 的 interface (cn.xie.SimpleSpring.dubbo.service.HelloService)
							
						--->ServiceAnnotationBeanPostProcessor.generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);		
							//获取 bean的名称
							
							
						--->registry.registerBeanDefinition(beanName, serviceBeanDefinition);
							//注册名称为 providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService 
							//类型为com.alibaba.dubbo.config.spring.ServiceBean 的 beanDefinition
										



					
			----------bean实例化---------	
			com.alibaba.dubbo.config.ApplicationConfig#0
			com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#0
			namePropertyDefaultValueDubboConfigBeanCustomizer
			com.alibaba.dubbo.config.RegistryConfig#0
			com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#1
			com.alibaba.dubbo.config.ProtocolConfig#0
			com.alibaba.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor#2
			helloServiceImpl
			providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService
			
			这些beanDefinition都通过 beanFactory 创建bean单例对象
			1、com.alibaba.dubbo.config.ApplicationConfig#0 
				在实例化和设置完属性后，经过 DubboConfigBindingBeanPostProcessor#0 (之前的流程)
				配置参数(当中还通过 namePropertyDefaultValueDubboConfigBeanCustomizer 对象赋默认值)
			
			2、RegistryConfig 通过 DubboConfigBindingBeanPostProcessor#1 设置属性和默认值
				ProtocolConfig 通过 DubboConfigBindingBeanPostProcessor#2 设置属性和默认值
			
			3、最终，ApplicationConfig、RegistryConfig、ProtocolConfig 只是构建了三个从 配置文件 到 spring bean 的过程，并没执行其他操作。
				helloServiceImpl 是一个简单 spring Bean 的创建
			
			4、最重要的是 providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService 的构建
				从之前的 BeanDefinition 得知 此bean 为一个 类型为 com.alibaba.dubbo.config.spring.ServiceBean 的bean
				
				4.1、 按spring 流程 先实例化 ServiceBean 对象
			
			
			
			
			
		-------------------------dubbo spi------------------------
		dubbo 的 spi 服务发现机制 由 ExtensionLoader 实现
		HelloIface iface = ExtensionLoader.getExtensionLoader(HelloIface.class).getExtension("MTS");
		
		ExtensionLoader 的构造方法为私有的，
		
		要构建一个 ExtensionLoader 由 ExtensionLoader.getExtensionLoader(HelloIface.class) 静态方法构建
		
		1、使用 ExtensionLoader.getExtensionLoader(HelloIface.class) 构建 ExtensionLoader 
			针对每个 接口（HelloIface）构建的 ExtensionLoader 为单例的
			ExtensionLoader 使用 全局常量缓存 ExtensionLoader 与实例化的 接口实现对象
			
			静态常量 EXTENSION_LOADERS=ConcurrentMap<接口类,ExtensionLoader> 缓存 每一个接口对应的 ExtensionLoader 
			静态常量 EXTENSION_INSTANCES= ConcurrentMap<实现类, 实例对象> 缓存
			

		
		2、 加载配置文件
		
			getExtensionClasses()
			--->loadExtensionClasses()
			
			ExtensionLoader 会缓存从配置文件META-INF/dubbo/internal/cn.xie.SimpleSpring.dubbospi.HelloIface中
			MTS=cn.xie.SimpleSpring.dubbospi.HelloSpiImpl
			wapper=cn.xie.SimpleSpring.dubbospi.FilterSpiImpl
			DTS=cn.xie.SimpleSpring.dubbospi.ByteSpiImpl
			adt=cn.xie.SimpleSpring.dubbospi.AdaptiveSpiImp
			
			cachedDefaultName	"MTS" (id=101)	

			
			ExtensionLoader.loadExtensionClasses(); 加载的各种接口实现类
			
			a.根据接口 @SPI("MTS") 标注，这种默认 实现名称
				cachedDefaultName = MTS
				
			b.如果 实现类的构造函数 含有 HelloIface 参数，则定义为 包装类 添加到
			  cachedWrapperClasses 
			  
			c.如果 实现类包含 @Adaptive 注解 ，设置为
				cachedAdaptiveClass
			
			d.如果 实现类为普通类  ，添加到
			  cachedNames	//Map<Class,name> 类为键，名称为值的Map集合
			  cachedClasses	 // Map<name,Class> 名称为键，类为值的Map集合 


		3、 实例化实现类
			Class<?> clazz = getExtensionClasses().get(name); 
			EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());	
			instance = (T) EXTENSION_INSTANCES.get(clazz);
			
			获取 MTS 对象的 class cn.xie.SimpleSpring.dubbospi.HelloSpiImpl ，实例化 HelloSpiImpl
			放入全局缓存 EXTENSION_INSTANCES
			instance = HelloSpiImpl 的实例化对象

			
		4、封装对象
			4.1 injectExtension 用来 自动注入属性 （IOC）
				injectExtension 的功能交由 初始化的 ExtensionFactory objectFactory; 处理
			
				在初始化 ExtensionLoader 时，会 先从 ExtensionFactory 配置文件 实例化一个 ExtensionFactory
				objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
				
			4.2 objectFactory 实际对象为 com.alibaba.dubbo.common.extension.factory.AdaptiveExtensionFactory
				这个对象用于 实例化所有配置文件中的 cachedClasses ，并通过扩展全部实例化
				放入 List<ExtensionFactory> factories; 属性中
				
				此时 List<ExtensionFactory> factories = com.alibaba.dubbo.common.extension.factory.SpiExtensionFactory
																					+
														com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory
				
			4.3 当调用 getExtension(Class<T> type, String name)  方法时 
				遍历 factories ，调用 getExtension 方法，如果获取到，就返回 对象
				SpiExtensionFactory 从 spi 获取 自适应 AdaptiveExtension 对象
				SpringExtensionFactory 从 Spirng 容器中获取
				
			4.4 将返回的对象设置为 4.1 对象的属性
			 
			 
			

			
			if (wrapperClasses != null && !wrapperClasses.isEmpty()) {
                for (Class<?> wrapperClass : wrapperClasses) {
                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                }
            }
			遍历所有的 wrapperClasses ，将 实例化的 HelloSpiImpl对象作为参数， 使用 wrapperClasse 的 构造函数实例化 wrapperClasses
			//public FilterSpiImpl( HelloIface helloIface) 
			//返回封装的对象 FilterSpiImpl
			instance = FilterSpiImpl 的实例化对象，封装了 HelloSpiImpl 对象
	

		
		------------@Adaptive 自适应接口实现-------------
		ExtensionLoader.getExtensionLoader(HelloIface.class).getAdaptiveExtension();
		用于获取 自适应接口实现
		第一种情况：如果我们定义了 自适应类（@Adaptive 注解修饰的类）
		
			@Adaptive
			public class AdaptiveSpiImp implements HelloIface
		
			在加载 配置文件时会 将 cachedAdaptiveClass 设置为 AdaptiveSpiImp 类，
			getAdaptiveExtension(); 方法就是获取 cachedAdaptiveClass 类的对象
		
		重要：第二种情况，方法自适应，@Adaptive 修饰接口方法
				@SPI
				public interface HelloIface {
				@Adaptive
				public void printHello(URL url);
	 
				public void sayBye();
				}
				
				通过 getAdaptiveExtension 获取的是一个 重写的 java代码编译后的 HelloIface对象HelloIface$Adaptive
				源码如下：
				import com.alibaba.dubbo.common.extension.ExtensionLoader;
				public class HelloIface$Adaptive implements cn.xie.SimpleSpring.dubbospi.HelloIface {
				public void printHello(com.alibaba.dubbo.common.URL arg0) {
						if (arg0 == null) throw new IllegalArgumentException("url == null");
						com.alibaba.dubbo.common.URL url = arg0;
						String extName = url.getParameter("hello.iface");
						if(extName == null) throw new IllegalStateException("Fail to get extension(cn.xie.SimpleSpring.dubbospi.HelloIface) name from url(" + url.toString() + ") use keys([hello.iface])");
						cn.xie.SimpleSpring.dubbospi.HelloIface extension = (cn.xie.SimpleSpring.dubbospi.HelloIface)ExtensionLoader.getExtensionLoader(cn.xie.SimpleSpring.dubbospi.HelloIface.class).getExtension(extName);extension.printHello(arg0);
					}
				public void sayBye() {
					throw new UnsupportedOperationException("method public abstract void 		cn.xie.SimpleSpring.dubbospi.HelloIface.sayBye() of interface cn.xie.SimpleSpring.dubbospi.HelloIface is not adaptive method!");
					}
				}
				
				@Adaptive 修饰接口方法 必须包含 URL参数或 参数有 getUrl (返回值为 URL) 方法 
				
				最终得到的对象是一个 可以根据 printHello(URL url) 参数 URL ,自动获取 对应的 接口实现类对象并执行 对应的 printHello 方法
				
				这么做的好处，代码的解耦
				
				比如 一个 应用程序需要 通过 ExtensionLoader 获取 一个接口对象
				代码中我们需要通过 extName 获取接口实现， T t = ExtensionLoader.getExtension(extName)
				再调用  t.doSome(); 方法
				
				下次如果我们更换了 接口的实现，需要 修改 代码中的 extName
				采用 上面的方式，我们只需要修改配置文件中的 URL 相关属性，
				就可以自动获取到对应的 实现类，执行方法
				
				当然，我们也可以使用第一种情况中自定义的 自适应类（@Adaptive 注解修饰的类）
				当执行 printHello 方法时，判断根据参数值的不同从 ExtensionLoader.getExtension 获取对应实现
				
				
				
				
	----------------- ServiceBean 的实例化过程-------------------------			
	通过 	ServiceAnnotationBeanPostProcessor	注册了服务bean 其中 helloServiceImpl 是一个普通bean 
	helloServiceImpl
	providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService
	
	其中 providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService 为发布服务的bean
	实现类为 com.alibaba.dubbo.config.spring.ServiceBean
	
	public class ServiceBean<T> extends ServiceConfig<T> 
		implements 
		InitializingBean, 
		DisposableBean,
        ApplicationContextAware, 
		ApplicationListener<ContextRefreshedEvent>, 
		BeanNameAware,
        ApplicationEventPublisherAware
	
				
		1.添加监听器 	registerListeners()	
			ServiceBean 为 ApplicationListener 的实现类，
			在注册监听器时将 bean（providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService） 添加到 
			ApplicationContext 的 applicationEventMulticaster	事件广播器 中
			
		2.实例化bean finishBeanFactoryInitialization(beanFactory);
						--->beanFactory.preInstantiateSingletons();
							--->beanFactory.getBean(beanName);
								--->beanFactory.doGetBean(name, null, null, false);
									--->beanFactory.getSingleton(String beanName, ObjectFactory<?> singletonFactory)
										--->beanFactory.createBean(beanName, mbd, args)
											--->beanFactory.doCreateBean(beanName, mbdToUse, args)
												
			2.1 实例化 createBeanInstance(beanName, mbd, args)
				
					  public ServiceBean() {
						super();
						this.service = null;
					}
					
	---------------------------------------其中 ServiceBean 包含一些静态常量------------------------------
					
					
	//协议的自动适配对象
	private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();

	//代理的自动适配对象
    private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();

    private static final Map<String, Integer> RANDOM_PORT_MAP = new HashMap<String, Integer>();

    private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("DubboServiceDelayExporter", true));
	
	----------------------------------------------------------------------------------------------------------
				
				
			2.2 属性值初始化 populateBean(beanName, mbd, instanceWrapper);
				ServiceBean.id             = cn.xie.SimpleSpring.dubbo.service.HelloService
				ServiceBean.interfaceName  = cn.xie.SimpleSpring.dubbo.service.HelloService" 
				ServiceBean.ref	           = HelloServiceImpl  
				
			2.3 执行 BeanNameAware.setBeanName 方法 invokeAwareMethods(beanName, bean)
				ServiceBean 实现了 BeanNameAware 执行 setBeanName(String name) 
			
			2.4 执行 BeanPostProcessor.postProcessBeforeInitialization(result, beanName) 方法
				设置 ServiceBean 实现了 ApplicationContextAware 接口 执行  setApplicationContext() 方法
				设置 ServiceBean 实现了 ApplicationEventPublisherAware 接口 执行  setApplicationEventPublisher() 方法
				
				ServiceBean.applicationContext 设置成功
				ServiceBean.applicationEventPublisher 设置成功
				
			2.5 执行  InitializingBean 接口方法 afterPropertiesSet(); 
			
				a.设置  ServiceBean.setProvider(providerConfig);
					provider= providerConfig (例子中为空)

				
				b.设置 ServiceBean.setApplication(applicationConfig);
					ServiceBean.application = ApplicationConfig
					
				c. 设置 ServiceBean.setModule(moduleConfig);
					ServiceBean.module = moduleConfig(例子中为空)
					 
				d.设置 ServiceBean.setRegistries(registryConfigs); 
					ServiceBean.registries = {RegistryConfig }
					
				e.设置 ServiceBean.setMonitor(monitorConfig);
					ServiceBean.monitor = {monitorConfig }(例子中为空)
					 
				f.设置ServiceBean.setProtocols(protocolConfigs)
					ServiceBean.protocols = {ProtocolConfig }
					
				判断是否是延迟发布，如果 supportedApplicationListener && (delay == null || delay == -1) 为真，
				就是没有设置是否延迟，但是支持 监听器 ，则认为是延迟发布
				
				
			此时 ServiceBean 的初始化工作完成,初始化工作只是将Bean 实例化并初始化参数值，并没有涉及服务发布
			
				ServiceBean.id             = cn.xie.SimpleSpring.dubbo.service.HelloService
				ServiceBean.interfaceName  = cn.xie.SimpleSpring.dubbo.service.HelloService
				ServiceBean.ref	           = HelloServiceImpl  
				ServiceBean.applicationContext = applicationContext
				ServiceBean.applicationEventPublisher = applicationContext
				ServiceBean.application = ApplicationConfig
				ServiceBean.protocols = {ProtocolConfig }
				ServiceBean.registries = {RegistryConfig }

			
			2.6 finishRefresh(); 
				--->publishEvent(new ContextRefreshedEvent(this));
				广播事件  ContextRefreshedEvent(this)
				
				ServiceBean 实现了ApplicationListener<ContextRefreshedEvent> 接口
				添加到了 监听器中 。执行监听器方法
				   @Override
					public void onApplicationEvent(ContextRefreshedEvent event) {
						if (isDelay() && !isExported() && !isUnexported()) {
							if (logger.isInfoEnabled()) {
							logger.info("The service ready on spring started. service: " + getInterface());
							}
							export();
						}
					}
				
			2.7 发布服务 export();
							---->doExport();
								---->校验信息
								---->doExportUrls()  
									//发布url
				doExportUrls() 
				a.获取注册的 url
					List<URL> registryURLs = loadRegistries(true);
				url=registry://128.160.11.24:6379/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo&dubbo=2.0.2&pid=9552&registry=redis&timestamp=1605237512648
				
				这里用到了 静态常量 
				 ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
				 
				********************************************************************************
				回顾之前的 getAdaptiveExtension 返回的是一个 ProxyFactory$Adaptive  动态类的对象
				
				此对象生成动态方法 根据 方法参数的 URL（可能是实现、包装）参数 获取 Constants.PROXY_KEY 的值，自动获取 对应值ProxyFactory的实现
				如果获取不到，则取默认配置的方法 @SPI("javassist")
				并执行 getProxy 方法
				  @Adaptive({Constants.PROXY_KEY})
				<T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;
				*********************************************************************************
				
				
				b.从代理工厂获取代理接口的代理执行器
				
				Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
				
				从registryURL 获取 Constants.PROXY_KEY 参数，为空，采用默认的 实现类 javassist
				从配置文件查看 
				stub=com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper
				jdk=com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory
				javassist=com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory
				
				实现类 JavassistProxyFactory 
				
				 @Override
				public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
				// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
				final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
				return new AbstractProxyInvoker<T>(proxy, type, url) {
				@Override
					protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
					return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
				}
				};
				}
				 
				 //生成一个 AbstractProxyInvoker 对象，
				 //AbstractProxyInvoker.doInvoke() 方法 用于执行 proxy 对象的 methodName 方法
				 
				 //原数据执行器
				 DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
				 
				 wrapperInvoker	
					----invoker	JavassistProxyFactory$1  (id=117)	
					----metadata	ServiceBean<T>  (id=35)	

				 

				
				
			
				c.Exporter<?> exporter = protocol.export(wrapperInvoker);
				
				发布服务
				和上面一样，
				Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
				返回的是适配器对象，
				protocol.export(wrapperInvoker);根据 wrapperInvoker 中的 invoker（存在 getURL 方法） 参数获取 
				protocol 参数，
				protocol = registry
				
				查询配置得知  registry=com.alibaba.dubbo.registry.integration.RegistryProtocol
				
				protocol.export(wrapperInvoker); 
				执行的 protocol.export(wrapperInvoker);
				是 ProtocolListenerWrapper  //包装对象
						---QosProtocolWrapper //包装对象
							----ProtocolFilterWrapper //包装对象
								----RegistryProtocol  //提供注册服务的对象
								
				RegistryProtocol.export(final Invoker<T> originInvoker) 
				执行注册发布之前需要在本地发布
				final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);
				获取 url 的 String export = origininvoker.getUrl().getParameterAndDecoded("export");
				
				dubbo://128.160.16.30:20880/cn.xie.SimpleSpring.dubbo.service.HelloService?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.SimpleSpring.dubbo.service.HelloService&bind.ip=128.160.16.30&bind.port=20880&dubbo=2.0.2&generic=false&interface=cn.xie.SimpleSpring.dubbo.service.HelloService&methods=getHello&pid=10376&side=provider&timestamp=1605256148804
				
				ProtocolListenerWrapper  //包装对象
						---QosProtocolWrapper //包装对象
							----ProtocolListenerWrapper //包装对象
								----DubboProtocol  //提供dubbo本地服务的对象
				




	----------------------netty4------------
	线程模型
	
	1.EventExecutorGroup 
	 继承自 ScheduledExecutorService  //一个 执行器 ExecutorService，可安排在给定的延迟后运行或定期执行的命令
			Iterable<EventExecutor>   //迭代器接口，用来获取 EventExecutor
	 
	 定义了最主要方法 
	EventExecutor next();	   //用于返回一个 EventExecutor 
	 
	
	
	2.EventExecutor  继承自 EventExecutorGroup ，一种特殊的 EventExecutorGroup 
	附带了查看一个线程是否在事件循环器中执行的方法
	boolean inEventLoop();

    boolean inEventLoop(Thread thread);
	
	简单理解这个方法，如果 EventExecutor 维护了一个线程对象 thread1
	当有main线程调用 EventExecutor.inEventLoop()时，
	会校验 Thread.currentThread() 和 thread1 是否为同一个线程对象
	
	
	3.DefaultEventExecutorGroup  extend MultithreadEventExecutorGroup //EventExecutorGroup 的默认实现
	
		----EventExecutor[] children; 具体的执行器
		----Set<EventExecutor> readonlyChildren;  执行器的只读集合，用于实现 Iterable 迭代器接口
		----EventExecutorChooserFactory.EventExecutorChooser chooser;   选择器，用于选择 children 中的 EventExecutor
		
		
		DefaultEventExecutorGroup构造时，
		a.初始化 children 为 DefaultEventExecutor
		b.初始化 readonlyChildren 为一个 只读 set 集合
		
	
	4.DefaultEventExecutor  extends SingleThreadEventExecutor   //EventExecutor 的默认实现
	
		SingleThreadEventExecutor 是一个单线程执行器，
		     private volatile Thread thread 执行任务线程，保存了一个线程对象（从 构造方法的 new ThreadPerTaskExecutor(threadFactory) 中获取的线程）
			 private final Queue<Runnable> taskQueue  保存一个任务队列，执行任务时不是调用线程，而是放到任务队列中
			 private volatile int state = ST_NOT_STARTED;  易变的线程状态
			 
			 
			 
	5.执行任务的过程	 

    public void execute(Runnable task) {
        if (task == null) {
            throw new NullPointerException("task");
        }
		//判断当前线程是否与 thread 是否一致
        boolean inEventLoop = inEventLoop();
		
		//将任务添加到 taskQueue 队列中 
        addTask(task);
		
		//如果当前线程不是执行线程，则尝试启动执行线程
        if (!inEventLoop) {
            startThread();
            if (isShutdown()) {
                boolean reject = false;
                try {
                    if (removeTask(task)) {
                        reject = true;
                    }
                } catch (UnsupportedOperationException e) {
                    // The task queue does not support removal so the best thing we can do is to just move on and
                    // hope we will be able to pick-up the task before its completely terminated.
                    // In worst case we will log on termination.
                }
                if (reject) {
                    reject();
                }
            }
        }
		
		
		//如果当前线程就是执行任务的线程，直接
        if (!addTaskWakesUp && wakesUpForTask(task)) {
            wakeup(inEventLoop);
        }
    }
	
	
	
	
   private void startThread() {
   
		//判断当前线程状态，未启动
        if (state == ST_NOT_STARTED) {
			
			//cas原子操作，如果state == ST_NOT_STARTED ，state=ST_STARTED，返回 true
            if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
                try {
				
					//启动线程
                    doStartThread();
                } catch (Throwable cause) {
                    STATE_UPDATER.set(this, ST_NOT_STARTED);
                    PlatformDependent.throwException(cause);
                }
            }
        }
    }
	
	
	//启动线程很简单，
	  private void doStartThread() {
		//断言 执行线程为空
        assert thread == null;
		
		//从 ThreadFactory 中获取一个线程，启动线程
        executor.execute(new Runnable() {
            @Override
            public void run() {
			
				//设置执行线程 为新获取的线程
                thread = Thread.currentThread();
				
				//判断 interrupted 标识，如果是中断状态，将线程置为中断状态
                if (interrupted) {
                    thread.interrupt();
                }

                boolean success = false;
                updateLastExecutionTime();
                try {
				
					//具体执行任务方法
                    SingleThreadEventExecutor.this.run();
                    success = true;
                } catch (Throwable t) {
                    logger.warn("Unexpected exception from an event executor: ", t);
                } finally {
                    for (;;) {
                        int oldState = state;
                        if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
                                SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
                            break;
                        }
                    }

                    // Check if confirmShutdown() was called at the end of the loop.
                    if (success && gracefulShutdownStartTime == 0) {
                        if (logger.isErrorEnabled()) {
                            logger.error("Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
                                    SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must " +
                                    "be called before run() implementation terminates.");
                        }
                    }

                    try {
                        // Run all remaining tasks and shutdown hooks.
                        for (;;) {
                            if (confirmShutdown()) {
                                break;
                            }
                        }
                    } finally {
                        try {
                            cleanup();
                        } finally {
                            STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
                            threadLock.release();
                            if (!taskQueue.isEmpty()) {
                                if (logger.isWarnEnabled()) {
                                    logger.warn("An event executor terminated with " +
                                            "non-empty task queue (" + taskQueue.size() + ')');
                                }
                            }

                            terminationFuture.setSuccess(null);
                        }
                    }
                }
            }
        });
    }
	
	在 DefaultEventExecutor 中实现为 
	
	//循环获取阻塞队列中的 任务 
	// taskQueue 是一个 BlockingQueue 阻塞队列
	//takeTask 会阻塞在 take 方法
	    @Override
    protected void run() {
        for (;;) {
            Runnable task = takeTask();
            if (task != null) {
                task.run();
                updateLastExecutionTime();
            }

            if (confirmShutdown()) {
                break;
            }
        }
    }
	
	
	
	//看下 main 线程 执行器关闭方法（此时 线程 executor  阻塞在 take 方法 ）
	executor.shutdownGracefully();
	-----------------------------------------------------------------------------
	//执行器状态 初始状态 private volatile int state = ST_NOT_STARTED
	//启动后 state = ST_STARTED
	ST_NOT_STARTED = 1 未启动
	ST_STARTED = 2         已启动
	ST_SHUTTING_DOWN = 3 关闭中
	ST_SHUTDOWN = 4          已关闭
	ST_TERMINATED = 5         已终结
	
	
	---------------------------main线程执行----------------------------------
	
	1、将 executor 状态设置为 ST_SHUTTING_DOWN
	
	2、使用 wakeup(boolean inEventLoop) ，唤醒阻塞的 DefaultEventExecutor 线程
		具体方法是：如果wakerup方法在线程中调用 && 当前状态为正常状态 ，说明 DefaultEventExecutor 线程正常运行，无需添加wakeup任务
						  如果 wakerup 方法由其他线程调用，或者 当前线程状态为待关闭状态，添加一个空的任务到 taskQueue 中
						
	3、返回 一个 terminationFuture 终结异步结果对象 给main线程 
	
	-------------------DefaultEventExecutor 线程-----------------------------					
						
	3、由于之前线程阻塞在 BlockingQueue.take(),此时添加了一个空的任务，继续执行
	
	4、通过判断 confirmShutdown 方法，从run的死循环中退出
	     4.1 cancelScheduledTasks(); 退出所有的计划任务
		 4.2 runAllTasks() || runShutdownHooks() 执行所有未执行的任务，执行关闭钩子（在线程 DefaultEventExecutor 中串行执行）
		 4.3 返回确认关闭为true
		 
	5.回到 doStartThread 方法中
		5.1 再次判断 state 是否为 ST_SHUTTING_DOWN 关闭中
		5.2 再次确认 confirmShutdown （确定是否存在任务）
		5.3 执行清理操作cleanup() 空方法，子实现可以扩展
		5.4 STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED); 将state 设置为 ST_TERMINATED 已终结
		5.5 threadLock.release(); 释放 信号量（计数器，阻塞在 acquire() 方法，由release()  方法释放）
		5.6 terminationFuture.setSuccess(null);  
			 这是关闭的异步对象
			实现方式：
			DefaultPromise<V>.setSuccess(V) line: 93	
		
			if (setSuccess0(result)) {
			
				//执行 监听器
				notifyListeners();
				return this;
			}
			
			 private boolean setSuccess0(V result) {
				return setValue0(result == null ? SUCCESS : result);
			}
			
			  private boolean setValue0(Object objResult) {
			  
			  
				// cas 原子操作将结果 result 置为 SUCCESS
				if (RESULT_UPDATER.compareAndSet(this, null, objResult) ||
					RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) {
					
					
					//检查所有的wait 在 Promise 对象上的线程并唤醒
					checkNotifyWaiters();
					
					return true;
					}
				return false;
				}
		 
			
			checkNotifyWaiters();  这里唤醒的是通过 DefaultPromise(AbstractFuture) .get() 方法 wait 在 future 对象上的线程
			 @Override
    public V get() throws InterruptedException, ExecutionException {
        await();

        Throwable cause = cause();
        if (cause == null) {
            return getNow();
        }
        if (cause instanceof CancellationException) {
            throw (CancellationException) cause;
        }
        throw new ExecutionException(cause);
    }
	
	
	Promise 接口继承 Future 接口，特殊的 Future 接口，可写的 Future （设置成功、失败）
	
	DefaultPromise(AbstractFuture) .await()
	@Override
    public Promise<V> await() throws InterruptedException {
	
		//判断result 是否为空或者为 不可撤销 UNCANCELLABLE，如果不为空或者是 UNCANCELLABLE ,则表示执行完成了
        if (isDone()) {
            return this;
        }

        if (Thread.interrupted()) {
            throw new InterruptedException(toString());
        }
		
		
		//检查死锁 判断当前线程（main ） 是否在 执行线程中，如果在，则存在死锁
        checkDeadLock();

		//获取 Promise 对象锁，如果没有执行完成，则添加 一个等待者到 Promise 中，当前线程 wait();
        synchronized (this) {
            while (!isDone()) {
                incWaiters();
                try {
                    wait();
                } finally {
                    decWaiters();
                }
            }
        }
        return this;
    }
	
	------------------DefaultEventExecutor 的 submit 异步提交任务方法-----------------------		
			
	异步原理:在 Promise 对象 notify 时可以唤醒其他线程的 get 方法
	
	
	在netty中 EventExecutor 接口继承自 EventExecutorGroup ，
	二者都抽象了 执行、提交任务的方法，EventExecutorGroup 侧重 next() 方法，表示 组的概念
	EventExecutor 侧重 inEventLoop() 方法 ，判断 是否在事件循环中
	上面的 DefaultEventExecutor 继承自 SingleThreadEventExecutor ，只是实现了 run() 方法，循环任务队列中的事件
	
	（为何要使用 SingleThreadEventExecutor 单线程执行器 管理 channel）
	单线程模型好处，一个 channel 都只在一个线程中处理，不用考虑多线程同步问题
	
	
	
	
	  EventExecutorGroup （next() 选择 EventExecutor）
	        ----EventExecutor1（NioEventLoop）----thread1----selector----channel1
																		                         ----channel2
																                                 ----channel3
			
			
			----EventExecutor2（NioEventLoop）----thread2----selector----channel4
																		                         ----channel5
																                                 ----channel6
			
			
			
			----EventExecutor3（NioEventLoop）----thread3----selector----channel7
																		                         ----channel8
																                                 ----channel9
	  
	  
	  
	NioEventLoop 就是 netty中 EventExecutorGroup 维护的 EventExecutor 的默认实现
	
	NioEventLoop 继承自 SingleThreadEventExecutor 也是单线程执行器
	NioEventLoop 维护了一个 选择器对象 selector 
	
	ChannelFuture channelFuture = bootstrap.bind(new InetSocketAddress(9878)); 过程
	
	main 线程
	ServerBootstrap(AbstractBootstrap<B,C>).bind(SocketAddress) line: 278	
			--->ServerBootstrap(AbstractBootstrap<B,C>).doBind(SocketAddress) line: 282	
				  --->ServerBootstrap(AbstractBootstrap<B,C>).initAndRegister() line: 333	
						---->channel = channelFactory.newChannel();
						        //构建一个 NioServerSocketChannel 对象
								
						---->ServerBootstrap.init(Channel) line: 143	
                                //初始化 NioServerSocketChannel 对象
								//添加一个 ChannelHandler(ChannelInitializer) 到 channel 的 pipeline
								//这个方法很重要
								// p.addLast(new ChannelInitializer<Channel>() {
									@Override
									public void initChannel(final Channel ch) throws Exception {
									final ChannelPipeline pipeline = ch.pipeline();
									ChannelHandler handler = config.handler();   //ChannelInitializer 中包括 添加 通过 bootstrap.handler(new  Myhandler())   添加的处理器
									if (handler != null) {
									pipeline.addLast(handler);
									}
									
									//添加一个任务到 执行线程，这个任务是用来添加 处理器的 （ServerBootstrapAcceptor）处理 连接的 handler
									ch.eventLoop().execute(new Runnable() {
									@Override
									public void run() {
									pipeline.addLast(new ServerBootstrapAcceptor(
											ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
										}
									});
									}
								});
				
						---->NioEventLoopGroup(MultithreadEventLoopGroup).register(Channel) line: 86	
								---->NioEventLoopGroup.next().register(channel);
										--->NioEventLoop(SingleThreadEventLoop).register(Channel) line: 74	
											--->promise.channel().unsafe().register(this, promise);
												  --->AbstractNioMessageChannel$NioMessageUnsafe(AbstractChannel$AbstractUnsafe).register(EventLoop, ChannelPromise) line: 464	
												         //这里用到了 NioMessageUnsafe 对象，此对象是 AbstractNioMessageChannel 内部类对象
														 //用于 具体 Channel  各种 操作，继承自  Channel$Unsafe 接口
														 //此接口必须在 IO线程（也就是处理channel的线程）中执行（localAddress、remoteAddress、register 等方法可以再其他线程（main）中执行）
														//register 方法由于会判断当前 线程是否是 EventLoop 中的线程，如果一致，则直接注册
														//如果不一致（如：主线程注册的，则将任务添加到 EventLoop（SingleThreadEventExecutor） 中）与上面的 DefaultEventExecutor 执行方式一致
														//例子中main 线程调用的 bind 方法，不在同一个线程，最终任务给 NioEventLoop 对应的线程
						
														
	NioEventLoop 对应的线程启动 SingleThreadEventExecutor.doStartThread() 调用 
	---> SingleThreadEventExecutor.this.run();
			--->NioEventLoop.run() line: 474	
				--->AbstractEventExecutor.safeExecute(Runnable) line: 163	
						--->AbstractNioMessageChannel$NioMessageUnsafe(AbstractChannel$AbstractUnsafe).register0(ChannelPromise) line: 508	
								---->NioServerSocketChannel(AbstractNioChannel).doRegister() line: 383	
								      //最终调用的是 selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); 
									  // register(Selector sel, int ops, Object att) 这是jdk 方法，将 通道 注册到 对应的 selector ，
									  //0 代表没有注册任何操作，this  附加对应包装的 channel
									  
								----> pipeline.invokeHandlerAddedIfNeeded(); 执行已经添加的 handler 
	
	
	
	
	ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
	
	
	---------------------当有 SocketChannel  连接到  NioServerSocketChannel------------------------------------
	
	
	ServerBootstrap
					-----parentGroup（EventExecutorGroup）----NioEventLoop1-1
																							-----NioServerSocketChannel1
																							-----NioServerSocketChannel2
						
																				----NioEventLoop1-2
																							-----NioServerSocketChannel3
																							-----NioServerSocketChannel4
																				
	
					-----childGroup（EventExecutorGroup）   ----NioEventLoop2-1
																					        -----SocketChannel1
																							-----SocketChannel2
						
																				----NioEventLoop2-2
																				            -----SocketChannel3
																							-----SocketChannel4
	
	从 连接到 NioServerSocketChannel1 (服务器通道)的 SocketChannel1 被 分配到 childGroup（EventExecutorGroup）中的一个 NioEventLoop2-1 线程处理
	
	
	
	*在 NioServerSocketChannel 中的 ChannelPipeline 添加了 一个 ServerBootstrapAcceptor ，
	
	1、当 NioServerSocketChannel 的线程 （parent）NioEventLoop 执行到 processSelectedKeys(); 也就是获取到一个连接事件 accpt事件
	
	2、NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: 656	
	
	3、if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                unsafe.read(); //处理 通道 底层
            }
	    //调用 AbstractNioMessageChannel$NioMessageUnsafe.read() line: 93	处理底层		
	
	4、int localRead = doReadMessages(readBuf);
	    // SocketChannel ch = SocketUtils.accept(javaChannel());  添加到 readBuf中
	
	5、pipeline.fireChannelRead(readBuf.get(i));
	   // NioServerSocketChannel 向管道发送读取消息，读取到的就是 SocketChannel ch
	
	
	
	6、之前 在 NioServerSocketChannel 中添加了一个 ServerBootstrapAcceptor 处理器，
	
	最后执行 ServerBootstrapAcceptor 的 channelRead 方法
	
	public void channelRead(ChannelHandlerContext ctx, Object msg) {
            final Channel child = (Channel) msg;

            child.pipeline().addLast(childHandler);

            setChannelOptions(child, childOptions, logger);

            for (Entry<AttributeKey<?>, Object> e: childAttrs) {
                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
            }

            try {
				//子组 注册 子通道 
                childGroup.register(child).addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) throws Exception {
                        if (!future.isSuccess()) {
                            forceClose(child, future.cause());
                        }
                    }
                });
            } catch (Throwable t) {
                forceClose(child, t);
            }
        }
	
		
	
    ---------NIO-------------
	模型 
	
	Selector
		---Set<SelectionKey>（包含子集合已选择键集 selectedKeys  已取消键集 canceledKeys ）
		    -----SelectionKey1-------ServerSocketChannel1
						----interestOps
						----readyOps
			
			-----SelectionKey2-------ServerSocketChannel2
			
			-----SelectionKey3-------SocketChannel1
			
			-----SelectionKey4-------SocketChannel3
			
			
	1.ServerSocketChannel1.register(select,0);
		构建一个 SelectionKey 添加到 Selector 的 循环遍历的集合中
		
	2. select.select(); 
		遍历集合中所有 SelectionKey ，查看是否有准备就绪操作 readyOps
	
	3.select.selectedKeys() 
		//当遍历到 SelectionKey 时 select.select() 返回，
		//通过 selectedKeys()  方法获取 这些准备就绪的 Set<SelectionKey> 集合
		
	4. 遍历  Set<SelectionKey> 集合 ，针对每一个 SelectionKey ，查看当前的 readyOps
		是什么？
		SelectionKey.OP_ACCEPT    服务端连接
		SelectionKey.OP_READ        读数据（检查读缓冲区是否有数据）
		SelectionKey.OP_CONNECT  客户端连接
		SelectionKey.OP_WRITE       写数据 （检查写缓冲区是否满）
		
		通过 比较 SelectionKey.readyOps() 与 上面的操作可以确定当前操作是什么？
		
		其中特殊的是 SelectionKey.OP_READ
		客户端连接断开，是一个读取操作，通过 channel.read(buff)=-1 判断
		
		如果 SelectionKey 的 interestOps 包含 SelectionKey.OP_WRITE 操作
		则 每次 select.select();  都会选择到 对应的 SelectionKey（代表写操作就绪）
		因为 SelectionKey.OP_WRITE 对于 写操作，是检查当前通道的写缓存是否满
		一般都不满，所以每次 select 的时候都会选择到通道对应的  SelectionKey
		
---------------------------


在netty中定义了一些 safeExecute 或者 Unsafe 接口实现（在 Channel 中维护了一个内部类实例 Unsafe unsafe）
safeExecute 表示当前执行已经确认了是线程安全的，不存在同步问题
（在 SingleThreadEventExecutor 中主要是通过判断当前执行方法的线程是否是 SingleThreadEventExecutor 的运行线程）
Channel 中维护了一个内部类实例 Unsafe unsafe 是处理通道底层的工具，需要确保 执行时是线程安全的。也是是上面提到的
同一个通道的任何操作都是在同一个线程中执行，


在注册完成后会执行
 pipeline.invokeHandlerAddedIfNeeded();
 这个方法会向管道执行处理器添加
new HelloInitializer()




-------------spring boot启动流程----------

Spring boot 比 Spirng Context 多出的是
对 spring.factories 文件配置的支持

通过配置 @Import(EnableAutoConfigurationImportSelector.class) (在Spring-boot-autoconfigure-1.5.22.RELEASE.jar 中加入的 )
读取 META-INF/spring.factories  中配置的 
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
cn.xie.SimpleSpring.configuration.HelloServiceAutoConfiguration  ，可以实现 bean 的 自动发现，这就是 starter 实现原理


ApplicationContext 对应 BeanFactory 多出了
1. BeanDefinitionRegistryPostProcessor BeanFactory的后置处理器
2. BeanPostProcessor  bean进行后置处理
3. 对资源 Resource 的管理


---------------简单的 spring  boot 启动流程---------------------

1. 将 SpringApplication.run(WebStarter.class, args); 后面的 参数类 WebStarter 添加到 beandefinition 
2. 遍历所有 beandefinition ，解析查找是否有 @Configuration @ComponentScan @Import  等标注，解析这些标注，将
   @Configuration 的类、@Bean 修饰的方法， @ComponentScan 引入的 包 @Import 引入的 类 添加到 beandefinition
3.再遍历 beandefinition ，看是否还又没有解析的 beandefinition，重复 2 方法


----------------详细的 spring boot 启动流程-----------------
1.初始 SpringApplication 
   1.1 根据 META-INF/spring.factories 初始化 List<ApplicationContextInitializer<?>> initializers 
   1.2 根据 META-INF/spring.factories 初始化 List<ApplicationListener<?>> listeners 
   1.3 设置main方法的类 this.mainApplicationClass = deduceMainApplicationClass();
   
   
2. 获取 META-INF/spring.factories  中的 SpringApplicationRunListener 接口实现，执行 starting 方法

3. 构建 ConfigurableEnvironment 

4. 创建ApplicationContext context = createApplicationContext();
	默认为 org.springframework.context.annotation.AnnotationConfigApplicationContext 对象
	4.1 实例化 对象  new DefaultListableBeanFactory();
	
	4.2 构建 beanDefinition 读取器  AnnotatedBeanDefinitionReader
	      this.reader = new AnnotatedBeanDefinitionReader(this);   //用来读取 beanDefinition 注解配置，this 为 BeanDefinitionRegistry 注册器对象
		  AnnotatedBeanDefinitionReader 实例化时，除了将 BeanDefinitionRegistry 属性 设置为 ApplicationContext 对象，
		  最重要的如下：
		  *************************
		 BeanDefinitionRegistry 中注册 解析 Configuration 注解的 BeanDefinitionRegistryPostProcessor 后置处理器 bean （在将 beandefinition 实例化为bean之前） 
		 org.springframework.context.annotation.internalConfigurationAnnotationProcessor =org.springframework.context.annotation.ConfigurationClassPostProcessor
		 
		 BeanDefinitionRegistry 中注册 解析 Autowired 注解的 BeanPostProcessor 后置处理器 bean （在将 beandefinition 实例化为bean之后）
		 org.springframework.context.annotation.internalAutowiredAnnotationProcessor= AutowiredAnnotationBeanPostProcessor
		 
		 BeanDefinitionRegistry 中注册 解析 Required 注解的 BeanPostProcessor 后置处理器 bean （在将 beandefinition 实例化为bean之后）
		 org.springframework.context.annotation.internalRequiredAnnotationProcessor= RequiredAnnotationBeanPostProcessor
		 
		 BeanDefinitionRegistry 中注册 解析 JSR-250 注解的 BeanPostProcessor 后置处理器 bean （在将 beandefinition 实例化为bean之后）
		 org.springframework.context.annotation.internalCommonAnnotationProcessor = CommonAnnotationBeanPostProcessor
		 
		 BeanDefinitionRegistry 中注册 解析 JPA注解的 BeanPostProcessor 后置处理器 bean （在将 beandefinition 实例化为bean之后）
		 org.springframework.context.annotation.internalPersistenceAnnotationProcessor = org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor
		 
		 BeanDefinitionRegistry 中注册 事件监听器处理器 EventListenerMethodProcessor
		 org.springframework.context.event.internalEventListenerProcessor= EventListenerMethodProcessor
		 
		 BeanDefinitionRegistry 中注册 事件监听器工厂 DefaultEventListenerFactory
		 org.springframework.context.event.internalEventListenerFactory= DefaultEventListenerFactory
		 
		  
	4.3 构建 beanDefinition 扫描器  ClassPathBeanDefinitionScanner
		  this.scanner = new ClassPathBeanDefinitionScanner(this);   //用来扫描 beanDefinition ，this 为 BeanDefinitionRegistry 注册器对象
		  
		  
		  
		  
5.获取 META-INF/spring.factories  中的 FailureAnalyzer 接口实现，设置为 SpringApplication 的analyzers 属性


6.SpringApplication.prepareContext(ConfigurableApplicationContext, ConfigurableEnvironment, SpringApplicationRunListeners, ApplicationArguments, Banner) line: 349	
   准备 ApllicationContext
   
   6.1  执行 上面配置的 ApplicationContextInitializer 的方法 initialize
          上面默认加载了 以下 ApplicationContextInitializer 接口实现，通过这些实现在实例化 ApplicationContextInitializer 之后初始化值
		[0]	DelegatingApplicationContextInitializer  (id=142)	 
		[1]	ContextIdApplicationContextInitializer  (id=143)	
		[2]	ConfigurationWarningsApplicationContextInitializer  (id=145)	
		[3]	ServerPortInfoApplicationContextInitializer  (id=146)	
		[4]	SharedMetadataReaderFactoryContextInitializer  (id=147)	
		[5]	AutoConfigurationReportLoggingInitializer  (id=148)	

   
   6.2  执行 上面配置的 SpringApplicationRunListener 的 方法  contextPrepared 
   
   6.3 向 ApplicationContext 中添加两个 bean （这里注册的是bean 而不是 beanDefinition ）
   springApplicationArguments ----> ApplicationArguments 参数对象
   springBootBanner               ----> Banner 打印对象
   
   6.4 注册 SpringApplication.run(HelloServiceAutoConfiguration.class, args); 中的 HelloServiceAutoConfiguration 类到 beandefinitions 中
   load(context, sources.toArray(new Object[sources.size()]));
   这里的sources 就是 HelloApplicationSt 类集合
   
   6.5 执行 SpringApplicationRunListener 的方法 contextLoaded();
   
   
   -----------------到这里------------
   一共注册了向 ApplicationContext （Beanfactory）中注册了 以下 BeanDefinition 
[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=146)	 =ConfigurationClassPostProcessor
[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=147)	
[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=148)	
[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=149)	
[4]	"org.springframework.context.event.internalEventListenerProcessor" (id=151)	
[5]	"org.springframework.context.event.internalEventListenerFactory" (id=152)	
[6]	"helloServiceAutoConfiguration" (id=153)	

  

   一共注册了向 ApplicationContext （Beanfactory）中注册了 以下 SingletonBean
   	"springApplicationArguments"  //参数bean 
	"autoConfigurationReport"      
	"springBootLoggingSystem" 
	"springBootBanner"               //打印bean


   
7.最重要的方法 refreshContext(context); 上面有详细解析
   重要的 
   执行步骤
   
   执行beanfactory 的处理器                                  ----》注册 bean 的后置处理器
   invokeBeanFactoryPostProcessors(beanFactory); ----》registerBeanPostProcessors(beanFactory);
   
   7.1 执行注册在ApplicationContext 中的 工厂后置处理器 // Invoke factory processors registered as beans in the context.
	    invokeBeanFactoryPostProcessors(beanFactory); 
         ---->PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
		 
		 这个方法叫 invokeBeanFactoryPostProcessors 如果 beanfactory 实现了 BeanDefinitionRegistry 接口
		 则需要先执行 BeanDefinitionRegistryPostProcessor BeanDefinitionRegistry 注册器的后置处理器）
		 a.先遍历 context 中的 BeanFactoryPostProcessors ，判断每一个 BeanFactoryPostProcessor 是否实现了 BeanDefinitionRegistryPostProcessor 接口
			如果实现了，执行 registryProcessor.postProcessBeanDefinitionRegistry(registry); 方法
			
		b.从 beanfactory 中获取 BeanDefinitionRegistryPostProcessor 类型的 beanDefinition 初始化bean 
		执行 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 
		（之前在 beandefinition 中注册了 org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的beanDefinition 类型为 ConfigurationClassPostProcessor ）
	      通过执行 internalConfigurationAnnotationProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，通过
		  执行 org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry 方法，解析每一个 beanDefinition  
		  是否包括 @PropertySource  @ComponentScan @Import @Bean 的所有注解
		  
		  （不管是什么标注，最基本的Spring 启动注解就是这几个 
		  常用的 @SpringBootApplication 注解包括 @ComponentScan @Configuration @Import(EnableAutoConfigurationImportSelector.class)  @Import(AutoConfigurationPackages.Registrar.class) 这些注解）
		  
		  
		  ConfigurationClassPostProcessor 包含 MetadataReaderFactory metadataReaderFactory 属性，这个对象用来生成类的元数据读取器
		  // 1. 元数据包括：ClassMetadata 类的名称、属性、父类等信息
		                           AnnotationMetadata 注解元数据，包括注解类，注解值
								   
				MetadataReaderFactory 用来生成类的元数据读取器 MetadataReader
				MetadataReader 可以获取上面的两种元数据
				
				
		  以下是执行 ConfigurationClassPostProcessor 具体步骤 
		  	----ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()
			
				--->ConfigurationClassPostProcessor.processConfigBeanDefinitions(registry);
				
					--->遍历所有 BeanDefinition String[] candidateNames = registry.getBeanDefinitionNames();
					
					--->判断 当前 beanDefinition 的属性 CONFIGURATION_CLASS_ATTRIBUTE 是否是 全配置类或轻配置类
							如果是 则代表当前配置类已经解析
							如果不是，就判断当前 beandefenition 是否包含 @Configuration（全配置类） @Component @ComponentScan @Import @ImportResource （轻配置类）
							注解，如果包含则 将 beanDefinition 添加到 configCandidates 待处理的配置类
					
				
					--->ConfigurationClassParser parser = new ConfigurationClassParser(
						this.metadataReaderFactory, this.problemReporter, this.environment,
						this.resourceLoader, this.componentScanBeanNameGenerator, registry);
						构架一个 配置类解析器
						
						 
						
					--->ConfigurationClassParser.parse();
					
						--->ConfigurationClassParser.parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
							//传入的是 StandardAnnotationMetadata 对象，此对象封装了 bean 的类信息以及 注解信息
							
							--->ConfigurationClassParser.processConfigurationClass(new ConfigurationClass(metadata, beanName));
							//封装 StandardAnnotationMetadata 与 bean名称 到 ConfigurationClass
							
								--->ConfigurationClassParser.doProcessConfigurationClass(configClass, sourceClass);
									
									--->ConfigurationClassParser.processPropertySource(propertySource); 
										//@PropertySource 解析
										
									--->AnnotationConfigUtils.attributesForRepeatable(
										sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
										//获取 所有的 @ComponentScan 属性
									
									--->ComponentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
										//解析 componentScan 所有属性
										
										--->scanner.doScan(StringUtils.toStringArray(basePackages));
											//扫描包并注册到 beanFactory 的 beanDefinitions 中
							
									---> ConfigurationClassParser.processImports(configClass, sourceClass, getImports(sourceClass), true);
									    // 处理 @Import 标签
										
										---> ConfigurationClassParser.getImports(sourceClass)
											//获取所有的 @Import 标签
											
										--->ConfigurationClassParser.processImports
											//处理 @Import 标签
											//遍历所有的 import 参数值
											--->candidate.isAssignable(ImportSelector.class)
											   //如果 值 为 ImportSelector 接口对象
											
												--->selector.selectImports(currentSourceClass.getMetadata());
													//如果 值 为 ImportSelector 接口对象
													// 调用 selectImports 方法获取 需要导入的类
													// @EnableAutoConfiguration 默认 添加了 @Import(EnableAutoConfigurationImportSelector.class)
													// EnableAutoConfigurationImportSelector 的 selectImports 方法 默认会 查找 
													//META-INF/spring.factories 文件中的 
													// org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项
													// 将其对于的类添加到 beandefinition 中
													// 这就是 各种 xxx-spring-boot-starter 实现原理
											
												---> ConfigurationClassParser.processImports(configClass, currentSourceClass, importSourceClasses, 	false);
												//处理selector 返回的 类 添加到 configClass 中
												
											---> candidate.isAssignable(ImportBeanDefinitionRegistrar.class )
												
												-->ParserStrategyUtils.invokeAwareMethods(
								
												-->configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
													//将 ImportBeanDefinitionRegistrar 对象添加到 configClass 中
												
											---> processConfigurationClass(candidate.asConfigClass(configClass));
											    // 其他的 直接添加到 configClass
												
						---> this.reader.loadBeanDefinitions(configClasses);
							//将所有的 configClasses 加载到 BeanDefinitions 中
							
							--->ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars
								(configClass.getImportBeanDefinitionRegistrars());
								//查 configurationClass 中的 ImportBeanDefinitionRegistrar 对象，并执行 注册方法 registerBeanDefinitions

	

     --------------------------------用例子看 processConfigBeanDefinitions 过程--------------------------------
	 
		SpringApplication.run(new Object[]{HelloServiceAutoConfiguration.class,TestDao.class}, args);
	
		@Configuration
		@ComponentScan(basePackages={"cn.xie.SimpleSpring.dao"})
		@Import(value={HelloImportSelector.class,
		cn.xie.SimpleSpring.bean.TestBean.class,
		cn.xie.SimpleSpring.registrar.HelloImportBeanDefinitionRegistrar.class})
		class HelloServiceAutoConfiguration 
		
		@Component
		class TestDao
		
		@Component
        class HelloBean 
		
	
		1.在上面的6.2 步骤load(Resource)中 将 HelloServiceAutoConfiguration.class,TestDao.class 这两个类添加到 beanDefinitions 中
		   此时 beandefinition 中有
		   
		   HelloServiceAutoConfiguration 
		   TestDao
		   
		 2. ConfigurationClassParser.processConfigBeanDefinitions() 方法执行
		 
		 3. 筛选出 所有 beandefinitions 中的 配置类，放入待解析 的beandefinition 集合中 candidates
		 
		 4. 构建一个 配置类解析器 ConfigurationClassParser
		 
		 5. 循环解析 待解析 的beandefinition 集合 candidates 中的 类
			
		 6.先解析 HelloServiceAutoConfiguration 类
		 
		 
		 -----------------解析 @ComponentScan 注解 ---------------------------
		 7. 解析HelloServiceAutoConfiguration 的  @ComponentScan 注解 扫描 包中的 类将为添加到beanDefinition 中的 类添加到 beanDefinition 中
		     此时 beandefinition 中有
		   
		   helloServiceAutoConfiguration 
		   testDao
		   helloBean
		 
		 8.再将 HelloBean 作为配置类解析
			这个过程与解析 HelloServiceAutoConfiguration 过程一致
		 
		 
		 
		 ------------------解析 @Import 注解------------------------
		 9.通过 processImports 方法 解析HelloServiceAutoConfiguration 的  @Import 注解 
		 
		10.遍历 import 的类  {
		cn.xie.SimpleSpring.bean.TestBean.class
		HelloImportSelector.class,
		cn.xie.SimpleSpring.registrar.HelloImportBeanDefinitionRegistrar.class}
		
		11.cn.xie.SimpleSpring.bean.TestBean 是一个普通 类（没有实现 ImportSelector 接口 ，没有实现 ImportBeanDefinitionRegistrar 接口）
		     
			 将 TestBean 当做 Configuration 类解析（与 HelloServiceAutoConfiguration 流程一样）此时 TestBean 并没有添加 到 beanDefinition 中
			将 TestBean 添加到解析器 的 configurationClasses 集合中 
		
		12.HelloImportSelector.class 实现了 ImportSelector 接口
		      调用 HelloImportSelector.selectImports 方法 ，获取需要注册的 bean 的类名 {cn.xie.SimpleSpring.bean.ImportBean}
			  
			  
			  将 cn.xie.SimpleSpring.bean.ImportBean 资源 作为参数 ，递归 的调用 processImports 
			  由于 ImportBean 是一个普通类，与11 步骤一致 添加到 解析器 的 configurationClasses 集合中 
			  
			  @EnableAutoConfiguration 注解包含 @Import(EnableAutoConfigurationImportSelector.class) 
			  EnableAutoConfigurationImportSelector.selectImports 方法默认会从 
			  META-INF/spring.factories 文件中查找并返回 org.springframework.boot.autoconfigure.EnableAutoConfiguration 属性对应的值
			  
		13.HelloImportBeanDefinitionRegistrar 实现了 ImportBeanDefinitionRegistrar 接口
			执行 HelloImportBeanDefinitionRegistrar 的aware 方法 （如果实现了aware接口）
			
			将 HelloImportBeanDefinitionRegistra 添加到主类 ConfigurationClass<helloServiceAutoConfiguration> 的 ImportBeanDefinitionRegistrar 集合中
			  
			  
		此时：  
		-------------------------------------------------------
		ConfigurationClassParser.configurationClasses 集合包含
		
		cn/xie/SimpleSpring/dao/HelloBean.class
		cn/xie/SimpleSpring/bean/ImportBean.class
		cn.xie.SimpleSpring.bean.TestBean
		cn.xie.SimpleSpring.configuration.HelloServiceAutoConfiguration
		cn.xie.SimpleSpring.dao.TestDao
		
	  
		ConfigurationClass<helloServiceAutoConfiguration>.ImportBeanDefinitionRegistrar 集合包含
		HelloImportBeanDefinitionRegistrar
		
		beanFactory 中 beandefinition 集合包含
		helloServiceAutoConfiguration 
		testDao
		helloBean
			  
		 
		 ---------------------------------------------------
	
		解析完 parser.parse(candidates); 并没有将import 的类添加到 beandefinition 中
		只是将Import 的普通对象添加到了 解析器的 configurationClasses 集合，
		将 实现 ImportSelector 接口的类通过 selectImports 方法返回的类添加到 configurationClasses
		将 ImportBeanDefinitionRegistrar 接口的类添加到 主类的 ImportBeanDefinitionRegistrar集合中
		
		14.获取上面的 configurationClasses 集合，去掉已经解析的beandefinition 中的class 
		分别注册到 beandefinitions 中，并执行 每一个待注册的 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
		注册完
		beanFactory 中 beandefinition 集合包含
		helloServiceAutoConfiguration 
		testDao
		helloBean
		cn.xie.SimpleSpring.bean.ImportBean
		cn.xie.SimpleSpring.bean.TestBean
		helloService
		registerBeanTest2
		
		
		定义的 bean 注册完成




	
	
	
	
	
	
8.刷新后的方法执行afterRefresh(context, applicationArguments);
9.执行 SpringApplicationRunListener 的方法 finished(); 




SpringApplication （启动类，负责构建 ApplicationContext 、Environment）
------------------------
	List<ApplicationContextInitializer<?>>
	List<ApplicationListener<?>> listeners


AnnotationConfigApplicationContext（基于注解的spring 上下文，同时实现了 BeanDefinitionRegistry 接口，能注册beandefinition）
------------------------
	AnnotatedBeanDefinitionReader 基于注解的 BeanDefinition 读取器
	ClassPathBeanDefinitionScanner 路径扫描器
	DefaultListableBeanFactory  bean工厂
	ConfigurableEnvironment  环境对象
	
	
DefaultListableBeanFactory  （单例bean工厂，bean的管理由其实现，其实现了 BeanDefinitionRegistry 接口，上面的 spring 上下文通过 DefaultListableBeanFactory 向其注册beandefinition）
--------------------------
beanDefinitionMap	ConcurrentHashMap<K,V>  beanDefinition 集合
singletonObjects	ConcurrentHashMap<K,V>   单例bean的集合


------------------------------------------------------------------------------------------------
SpringApplication 负责构建  ConfigurableEnvironment，ApplicationContext ，同时发送 ApplicationContext 构建各个阶段事件
ApplicationContext 负责读取到注解或配置中的 beandefine 并注册到 BeanFactory 中
BeanFactory 负责将注册的 beandefinition 构建为 bean
-------------------------------------------------------------------------------------------------

@Configuration
@Import(HelloImportSelector.class)
HelloServiceAutoConfiguration

configClass 主配置类（HelloServiceAutoConfiguration） （@Configuration @Bean 修饰的类）处理流程  
--------------
   ConfigurationClassParser parser 处理器对象
	@Import 处理流程 （将import 的 value 放入集合 importCandidates）
	processImports(ConfigurationClass configClass, SourceClass currentSourceClass,Collection<SourceClass> importCandidates, boolean checkForCircularImports)
	
	遍历 importCandidates 集合
	1.	如果 导入的是 ImportSelector 接口实现
		调用ImportSelector .selectImports 方法
		将方法返回的字符串数组构建为 类数组 importSourceClasses
		递归调用 
		processImports(configClass, currentSourceClass, importSourceClasses, false);
		
	2.如果 导入的是 ImportBeanDefinitionRegistrar 接口实现
		将 ImportBeanDefinitionRegistrar 实现类添加到 configClass 的 importBeanDefinitionRegistrars 的map中，key 为 ImportBeanDefinitionRegistrar value 为 configClass 的元数据
		
		之后通过org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars 遍历 所有map ，
		执行 ImportBeanDefinitionRegistrar.registerBeanDefinitions(configClass的元数据，registry);
		
	3.如果 导入的是其他（普通类）类
		将 此类作为 configClass 递归调用 
		processConfigurationClass(candidate.asConfigClass(configClass));
		最终是将 class添加 到 parser 的  configurationClasses  的 map 集合中
		
		之后通过 this.reader.loadBeanDefinitions(configClasses); 遍历 所有的 map 集合中的 configuration 类，并注册到 beanRegister中
		
		

		
		
		
		
@Import 总的处理流程
SpringApplication.run(new Object[]{HelloServiceAutoConfiguration.class}, args);
1.run 方法向 register 中注册 HelloServiceAutoConfiguration
2.获取 注册的 beanDefinition （HelloServiceAutoConfiguration）
3.解析 HelloServiceAutoConfiguration 
4.获取到 HelloServiceAutoConfiguration 中的 Import 标注的类
5.如果是 ImportSelector 获取接口返回，再递归解析
	如果是 ImportBeanDefinitionRegistrar 放入 HelloServiceAutoConfiguration 的configClass 的 Registrar 集合中
	如果是普通类，放入 读取器的 configurationClasses 集合中
6.获取到 configurationClasses 并注册到 register 中
7.获取 HelloServiceAutoConfiguration 的 configClass 的 Registrar 集合
   并执行 Registrar 接口方法 向 register 中注册
8.在比较 register 中注册的 beanDefinition 与之前获取的 beanDefinition
9.如果有新增，将新增的beandefinition 作为 configClass 循环解析





-------------ApplicationContext分析-------------
ClassPathXmlApplicationContext ctx  = new ClassPathXmlApplicationContext("helloapplication.xml");
MchtInfoInterface infer = (MchtInfoInterface)ctx.getBean("mchtService");

refresh()方法详解
1.obtainFreshBeanFactory 创建BeanFactory
  1) 构建一个DefaultListableBeanFactory对象
  2）构建一个XmlBeanDefinitionReader对象，包含DefaultListableBeanFactory对象属性
  3）XmlBeanDefinitionReader处理配置文件并将 BeanDedinition 设置到 DefaultListableBeanFactory 的map属性中
  
2.prepareBeanFactory 准备BeanFactory 
  1) 设置类加载器
  2）设置忽略的接口
  3）设置BeanPostProcessor
  
3.postProcessBeanFactory 留给子类实现的扩展方法，用来自定义相关配置

4.invokeBeanFactoryPostProcessors(configurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)执行BeanFactoryPostProcessor
   1)先执行传入的List<BeanFactoryPostProcessor> 
   2)再去工厂中获取beanFactory.getBeanNamesForType 获取BeanDefinitionRegistryPostProcessor类型的bean
   3)执行invokeBeanDefinitionRegistryPostProcessors 
   4)再去工厂中获取beanFactory.getBeanNamesForType 获取BeanFactoryPostProcessor类型的bean
   5)执行invokeBeanFactoryPostProcessors

5.registerBeanPostProcessors 注册BeanPostProcessor
   1)通过beanfactory查询所有配置bean中BeanPostProcessor类型的bean名称
   2)获取beanfactory的beanPostProcessors对象，之前操作已经添加了
     ApplicationContextAwareProcessor
	 ApplicationListenerDetector
	 PostProcessorRegistrationDelegate$BeanPostProcessorChecker
	 这三个beanPostProcessor
   3)实例化1）步骤中查询的BeanPostProcessor对象，并将对象添加到beanPostProcessors中
   
6.initMessageSource 初始化国际化资源

7.initApplicationEventMulticaster 初始化事件广播器
  1）判断Beanfactory中是否有applicationEventMulticaster对象
  2) 没有就实例化一个SimpleApplicationEventMulticaster(beanFactory)对象，赋给ClassPathXmlApplicationContext对象的 applicationEventMulticaster 属性
  3）将对象添加到Beanfactory管理的单例对象中。

8.onRefresh
  留给子类扩展的模板方法，在单例对象实例化之前执行
  
9. registerListeners 注册监听器ApplicationListener 到ClassPathXmlApplicationContext.applicationEventMulticaster(广播器)中
  1） 获取ClassPathXmlApplicationContext 中已经配置的ApplicationListener，添加到 applicationEventMulticaster
  2） 查询所有配置的ApplicationListener类型的bean的名称，添加到applicationEventMulticaster中
  3） 获取到ApplicationContext中的已经加载的ApplicationEvent事件， earlyApplicationEvents
  4） 调用applicationEventMulticaster.multicastEvent()方法广播earlyApplicationEvents事件
  5） 遍历applicationEventMulticaster中所有的ApplicationListener监听器，并执行
  
10. finishBeanFactoryInitialization 初始化所有未初始化的非懒加载的单例对象
  1）添加植入属性的处理器比如${...} beanFactory.addEmbeddedValueResolver
  2）冻结所有配置的变更 beanFactory.freezeConfiguration();
  3）初始化所有的未初始化的非懒加载的单例对象preInstantiateSingletons
     3.1）遍历BeanFactory中所有定义的bean名称beanDefinitionNames
	 3.2）判断当前bean是否是FactoryBean
	 3.3）如果不是，直接调用getBean(beanName);
	 执行完成所有的bean都添加到了容器中

11. finishRefresh 完成刷新，发布完成刷新事件



配置       BeanDefinitionReader   

                  ----                 ----------------------ApplicationContext---------------------------------------------------------------------
Xml               |  |                 |   
Properties    --> |  | -------1--------|-->|-------------- BeanFactory--------------|        
annotation        |  |                 |   |                                        |                          ApplicationEvent
.                 |  |                 |   |            BeanDedinitions             |                                 ↓    
.                 |  |                 |   |                   ↓                    |                                 ↓
.                 |  |                 |   |                   ↓                    |        |------------ApplicationEventMulticaster---------|
.                 |  |                 |   |           beanPostProcessor	        |        |                                                |
.                 |  |                 |   |                   ↓                    |        |               ApplicationListener              |
.                 |  |                 |   |           beanPostProcessor            |        |                                                |
.                 |  |                 |   |                   .                    |        |               ApplicationListener              |
.                 |  |                 |   |                   .                    |        |                                                |
.                 |  |                 |   |                   .                    |        |                                                |
.                 |  |                 |   |                   .                    |        |-------------------------------------------------
.                 |  |                 |   |                   .                    |
.                 |  |                 |   |                   .                    |
.                 |  |                 |   |                   .                    |
                  ----                 |   |----------------------------------------|
				                       |                   ↓         ↑
				                       |                   4         ↑
									   |				  ↓         ↑
									   |				  ↓         ↑
												BeanDefinitionRegistryPostProcessor
														  ↓    .    ↑
														  ↓    .    ↑
												BeanDefinitionRegistryPostProcessor
														  ↓         ↑
				                                    BeanFactoryPostProcessor
														  ↓    .    ↑
 														  ↓    .    ↑
												    BeanFactoryPostProcessor  
														       
				  
				  
-----------BeanFactory.getBean分析---------
在	ApplicationContext执行finishBeanFactoryInitialization会初始化所有的bean
先看下	BeanFactory中规定的生命周期
BeanFactory的实现应该尽可能支持标准的生命周期，
 创建生命周期
 0.完成 bean实例化及属性填充后
 1.BeanNameAware's {@code setBeanName}   实现了名称感知接口的bean 设置bean名称
 2.BeanClassLoaderAware's {@code setBeanClassLoader} 实现了类加载器感知接口的bean 设置类加载器
 3.BeanFactoryAware's {@code setBeanFactory} 实现了beanfactory感知接口的bean 设置beanfactory
 4.EnvironmentAware's {@code setEnvironment} 实现了环境感知接口的bean 设置环境
 5.EmbeddedValueResolverAware's {@code setEmbeddedValueResolver} 内置值解析器接口的bean 设置内置值解析器
 6.ResourceLoaderAware's {@code setResourceLoader}
 
  ----只有在ApplicationContext容器中才会执行
 7.ApplicationEventPublisherAware's {@code setApplicationEventPublisher} 
 8.MessageSourceAware's {@code setMessageSource}
 9.ApplicationContextAware's {@code setApplicationContext}
 10.ServletContextAware's {@code setServletContext}
 11.{@code postProcessBeforeInitialization} methods of BeanPostProcessors 执行BeanPostProcessors的postProcessBeforeInitialization方法
 12.InitializingBean's {@code afterPropertiesSet}  执行 InitializingBean的afterPropertiesSet方法
 13.a custom init-method definition 调用bean的 init-method方法
 14.{@code postProcessAfterInitialization} methods of BeanPostProcessors 执行BeanPostProcessors的postProcessAfterInitialization方法
 
 
 通过实验得到的生命周期
 1.>>>>>>>>>>>InstantiationAwareBeanPostProcessor postProcessBeforeInstantiation
   在bean还没有实例化前执行InstantiationAwareBeanPostProcessor 接口的实例化前置方法postProcessBeforeInstantiation
   此方法在上面的0阶段

 2.>>>>>>>>>>SimpleService construct
   实例化bean
   此方法在上面的0阶段
   
 3.>>>>>>>>>>>InstantiationAwareBeanPostProcessor postProcessAfterInstantiation
   在bean实例化后执行 InstantiationAwareBeanPostProcessor 接口的实例化后置方法 postProcessAfterInstantiation
   此方法在上面的0阶段
   
 4.>>>>>>>>>>>InstantiationAwareBeanPostProcessor postProcessPropertyValues
   在设置属性之前执行 InstantiationAwareBeanPostProcessor 的修改属性值方法 postProcessPropertyValues
   此方法在上面的0阶段
   
 5.>>>>>>>>>>SimpleService set property
   初始化bean属性
   此方法在上面的0阶段
   
 6.>>>>>>>>>>BeanNameAware setBeanName
   如果bean实现了 BeanNameAware 接口，执行 setBeanName 方法
   对象上面的1-10阶段的各种Aware接口方法
   
 7.>>>>>>>>>BeanPostProcessor postProcessBeforeInitialization
   执行BeanPostProcessor的初始化前置方法 postProcessBeforeInitialization
   对应在上面的11阶段
   
 8.>>>>>>>>>>>InstantiationAwareBeanPostProcessor postProcessBeforeInitialization
   由于InstantiationAwareBeanPostProcessor实现了 BeanPostProcessor接口 ，同样需要执行 postProcessBeforeInitialization
   对应在上面的11阶段
   
 9.>>>>>>>>>>InitializingBean afterPropertiesSet
   如果bean实现了 InitializingBean 接口，执行 afterPropertiesSet 方法
   对应上面的12阶段
   
 10.>>>>>>>>>>BeanNameAware init_method 
    执行bean自定义初始化方法
	对应13阶段
	
 11.>>>>>>>>>BeanPostProcessor postProcessAfterInitialization
    执行BeanPostProcessor的初始化后置方法 postProcessAfterInitialization
	对应14阶段
	
 12.>>>>>>>>>>>InstantiationAwareBeanPostProcessor postProcessAfterInitialization
    同上

 销毁生命周期
 1.{@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors 
 2.DisposableBean's {@code destroy}
 3.a custom destroy-method definition  
 
 
 ----spring三级缓存源码分析----
 
 beanFactory.getBean(beanName);
 实际对象为DefaultListableBeanFactory.getBean(beanName);
 具体bean信息如下
  <bean id="mchtService" class="cn.xie.dubbo.service.HelloMchtInfoImpl"> 
    <property name="oprInfo">
			<ref bean="oprService" />
		</property>
 </bean>
 <bean id="oprService" class="cn.xie.dubbo.service.OprInfoImpl"> 
    <property name="mchtInfo">
			<ref bean="mchtService" />
		</property>
 </bean>
 
 1.DefaultListableBeanFactory.getBean("mchtService"); 
   实际调用方法为 doGetBean(name, null, null, false); 

	1）getSingleton(String beanName, boolean allowEarlyReference)
	    从容器中获取bean，allowEarlyReference 为是否允许提前暴露bean对象
		
	     1.1） this.singletonObjects.get(beanName); 从一级缓存中获取mchtService
		 
	     1.2）if (singletonObject == null && isSingletonCurrentlyInCreation(beanName))
	          如果一级缓存中没有，但是正在创建的bean集合singletonsCurrentlyInCreation 中存在这个bean
			  此时的逻辑之后处理
			  
	     1.3）当前mchtService不在正在创建，返回false，直接返回NULL;
	
	2）没有从容器中获取到
	    2.1）将当前bean名称添加到 alreadyCreated 集合中
		2.2）final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); 获取bean的定义信息
		2.3）判断当前bean是否存在depend-on依赖的对象
		
	3）执行getSingleton(String beanName, ObjectFactory<?> singletonFactory) 
		     这个传入的对象为内部类
			 new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					}
			3.1）	Object singletonObject = this.singletonObjects.get(beanName); 
			        从一级缓存获取bean
			
			3.2）	logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
			       开始创建提前暴露的bean对象
				   
			3.3） singletonObject = singletonFactory.getObject(); 
			      调用内部类ObjectFactory的回调方法getObject
				  
				  public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
						
				  （逻辑关系 BeanFactory.getSingleton() 方法 调用 ObjectFactory.getObject() 方法
				    ObjectFactory.getObject() 回调 BeanFactory.createBean()方法）
			
            3.4） return createBean(beanName, mbd, args);
 			        创建bean对象
			
			        a. Creating instance of bean 'mchtService'
					   开始实例化bean
					
					b.  Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
						if (bean != null) {
						return bean;  
						}
						
					   protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
								Object bean = null;
								if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
									// Make sure bean class is actually resolved at this point.
								if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
								Class<?> targetType = determineTargetType(beanName, mbd);
								if (targetType != null) {
									bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
								if (bean != null) {
									bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
									}
								}
							}
						mbd.beforeInstantiationResolved = (bean != null);
						}
						return bean;
						}
					   查看是否有 InstantiationAwareBeanPostProcessors 并执行
					   接口的 postProcessBeforeInstantiation 方法，对应 实验中生命周期的-1 
					   
					   如果 postProcessBeforeInstantiation 返回实例化对象，则方法返回此对象，
					   如果 postProcessBeforeInstantiation 返回空，则方法返回空。
					   
					c. 如果 resolveBeforeInstantiation 返回不为空，则createBean直接返回此对象
					
					d. Object beanInstance = doCreateBean(beanName, mbdToUse, args);
					    
						//定义一个bean的包装对象，用来设置bean的属性
						BeanWrapper instanceWrapper = null;
					
					    //实例化bean对象并封装到包装类 BeanWrapper 对应 实验中生命周期的-2 
					    instanceWrapper = createBeanInstance(beanName, mbd, args);
						
						//构建一个ObjectFactory对象，并将 ObjectFactory 对象放入三级缓存，用户提前暴露 mchtService 对象
						//构建的 ObjectFactory 是一个内部类对象，包含了getObject() 回调方法
						addSingletonFactory(beanName, new ObjectFactory<Object>() {
						@Override
							public Object getObject() throws BeansException {
							
							        //实例化的mchtService 对象传入回调方法
									return getEarlyBeanReference(beanName, mbd, bean);
								}
						});
						
					此时缓存内容：
						
					一级缓存singletonObjects             二级缓存 earlysingletonObjects                三级缓存singletonFactories       
	                ---------------------------          ------------------------------                ----------------------
					      		                                                                       ObjectFactory<mchtService>
						
						
					e. populateBean(beanName, mbd, instanceWrapper);
						初始化 对象 mchtService
						//如果定义了 InstantiationAwareBeanPostProcessors 对象，
						//则执行InstantiationAwareBeanPostProcessor .postProcessAfterInstantiation 方法 
						//对应实验步骤-3
						if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
									for (BeanPostProcessor bp : getBeanPostProcessors()) {
											if (bp instanceof InstantiationAwareBeanPostProcessor) {
												InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
												if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
													continueWithPropertyPopulation = false;
												break;
												}
											}
										}
									}
						
						//如果定义了 InstantiationAwareBeanPostProcessors 对象，
						//则执行InstantiationAwareBeanPostProcessor .postProcessPropertyValues 方法 
						//对应实验步骤-4
						for (BeanPostProcessor bp : getBeanPostProcessors()) {
								if (bp instanceof InstantiationAwareBeanPostProcessor) {
								InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
								pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
								if (pvs == null) {
								return;
								}
							}
						}
						
						//bean对象设置属性值
						applyPropertyValues(beanName, mbd, bw, pvs);
						
				    f. 	BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);
					     初始化一个BeanDefinition 属性值处理器
						 
						 //处理当前属性值，返回处理后的值
						 //pv属性 PropertyValue 对象，保存当前bean定义的property 
						 //originalValue 原始值 
						 //mchtService需要设置属性 oprService
						 //originalValue  表示 beanName为oprService 的 RuntimeBeanReference 对象 
                         
                         Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
						 
						 //按照上面流程获取 oprService 对象
						 Object bean = this.beanFactory.getBean(refName);
						 
					-------------------此时缓存中的对象为----------------
						
				      一级缓存singletonObjects   >>>         
					  二级缓存 earlysingletonObjects  >>>
					  三级缓存singletonFactories   >>> ObjectFactory<mchtService>，ObjectFactory<oprService>
					  
					  
					 g . 当 oprService 对象初始完成，需要设置 mchtService 属性时
					     需要执行
						 
						1.Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
						 Object bean = this.beanFactory.getBean(refName);
						 
						也就是从第1步中的 getSingleton(String beanName, boolean allowEarlyReference) 方法 获取 mchtService 对象
						
						尝试从一级缓存 singletonObjects 获取 mchtService ，为空
						尝试从二级缓存 earlySingletonObjects 获取 mchtService 为空
						尝试从三级缓存 singletonFactories 获取 mchtService ，返回一个 ObjectFactory<mchtService> 对象
						
						2. 执行对象的 singletonFactory.getObject(); 方法获取bean
						之前写过这个方法是一个回调方法，其实调用的是BeanFactory的
						
						public Object getObject() throws BeansException {
							return getEarlyBeanReference(beanName, mbd, bean);
						}
						
						
						由于 hasInstantiationAwareBeanPostProcessors 为false
						直接返回的是 实例化的 （未初始化） 的 mchtService 对象
						
						3.//将 mchtService 对象添加到 二级缓存。从三级缓存中移除
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
						
					-------------------此时缓存中的对象为----------------
						
				      一级缓存singletonObjects   >>>         
					  二级缓存 earlysingletonObjects  >>> mchtService
					  三级缓存singletonFactories   >>> ObjectFactory<oprService>	
					  
					 此时已经获取到了 mchtService 对象,
					 oprService的属性已经赋值完毕
					 
					 h. exposedObject = initializeBean(beanName, exposedObject, mbd);
					 
					   1. invokeAwareMethods(beanName, bean);                对应步骤6
					      执行Aware接口方法
						  
					   2.  wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);  对应步骤 7-8
					   执行 BeanPostProcessors 的   BeanPostProcessorsBeforeInitialization 方法 

					   3. invokeInitMethods(beanName, wrappedBean, mbd);  
						((InitializingBean) bean).afterPropertiesSet();
					     执行实现接口 InitializingBean 的 afterPropertiesSet 方法               对应步骤 9
						 
						 invokeCustomInitMethod(beanName, bean, mbd);  
						 执行自定义 init-method 方法                                            对应步骤 10
							
					   4. wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);       对应 11-12
					     执行 BeanPostProcessors 的   BeanPostProcessorsAfterInitialization 方法  
						 
						 
						 
					


						
					    
						sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					   });
					   
					i . 这里的主要回调流程如下
					    >>>>>BeanFactory.getBean(mchtService)
						---->BeanFactory.doGetBean(mchtService)
						---->BeanFactory.getSingleton(mchtService, ObjectFactory<?>)
						---->ObjectFactory.getObject()
						---->BeanFactory.createBean(mchtService)
						---->BeanFactory.populateBean(mchtService, RootBeanDefinition, BeanWrapper) 
						
						---->BeanFactory.getBean(oprService)
						---->BeanFactory.doGetBean(oprService)
						---->BeanFactory.getSingleton(oprService, ObjectFactory<?>)
						---->ObjectFactory.getObject()
						---->BeanFactory.createBean(oprService)
						---->BeanFactory.populateBean(oprService, RootBeanDefinition, BeanWrapper) 
						
							
					
						
					g . oprService 创建完成，BeanFactory.createBean(oprService) 执行完成
						  返回到BeanFactory.getSingleton(oprService, ObjectFactory<?>) 方法
						  
						 //从正在创建集合中移除 oprService 
						 singletonsCurrentlyInCreation.remove(beanName) 
						 
						 //oprService添加到一级缓存
						 //oprService 从二级缓存移除
						 //oprService 从三级缓存移除
						 addSingleton(beanName, singletonObject);
						 
						this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
						this.singletonFactories.remove(beanName);
						this.earlySingletonObjects.remove(beanName);
						this.registeredSingletons.add(beanName);
						  
						-------------------此时缓存中的对象为----------------
						
				      一级缓存singletonObjects   >>>  oprService       
					  二级缓存 earlysingletonObjects  >>> mchtService
					  三级缓存singletonFactories   >>> 	 
						
						 
						 
					 h . BeanFactory.getBean(oprService) 执行完成
					     返回 BeanFactory.createBean(mchtService) 方法
					 
						已经获取到 oprService BeanFactory.createBean(mchtService) 与g步骤一样
						返回到BeanFactory.getSingleton(mchtService, ObjectFactory<?>) 方法
						
						//从正在创建集合中移除 mchtService 
						 singletonsCurrentlyInCreation.remove(beanName) 
						 
						 //mchtService添加到一级缓存
						 //mchtService 从二级缓存移除
						 //mchtService 从三级缓存移除
						 addSingleton(beanName, singletonObject);
						
						 一级缓存singletonObjects   >>>  oprService  ,mchtService     
						二级缓存 earlysingletonObjects  >>> 
						三级缓存singletonFactories   >>> 	 
						
						
						此时两个对象以及所有的生命周期全部执行完成
						
						
						
	--------------------getBean(String name) 方法调用栈-------------------
	---->doGetBean(name, null, null, false)
	
	     ---->getSingleton(String, ObjectFactory<?>)
	   
	          ---->new ObjectFactory<Object>().getObject()
		  
		           ---->createBean(beanName, mbd, args)
			 
			             ---->resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)    	
				              //执行InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation 方法
				   
				         ---->doCreateBean(beanName, mbdToUse, args)
				
				              ----> createBeanInstance(beanName, mbd, args)
				                    //实例化对象 
									
					          ----> addSingletonFactory(beanName, new ObjectFactory<Object>())
							        //添加一个可获取对象（或代理对象）getObject() 内部类对象 到第三缓存
									
				              ----> populateBean(beanName, mbd, instanceWrapper)
				                    //初始化对象
					   
					                ---->InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation
					   
					                ---->InstantiationAwareBeanPostProcessor.postProcessPropertyValues
					   
					                ---->applyPropertyValues(beanName, mbd, bw, pvs);   //属性设置 
					   
				              ----> initializeBean(beanName, exposedObject, mbd)
				   
					                ---->invokeAwareMethods(beanName, bean);  //执行Aware接口方法
					   
					                ---->applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
					                      //执行 BeanPostProcessors 的   BeanPostProcessorsBeforeInitialization 方法 
						  
					                ---->invokeInitMethods(beanName, wrappedBean, mbd);
					                      // 执行（InitializingBean) bean).afterPropertiesSet()接口方法以及 init-method 自定义初始化方法
						  
					                ---->applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
					                      // 执行 BeanPostProcessors 的   BeanPostProcessorsAfterInitialization 方法  
						  
				              ----> return Object earlySingletonReference = getSingleton(beanName, false);
				                    //检查当前对象是否在二级缓存中，如果在则 替换当前bean（可能是一个代理对象） 并返回 
						
		      ---->addSingleton(beanName, singletonObject);
			       //将beanName 添加到第一缓存，从第二、第三缓存移除					
						
						
    ------------------简单说下A和B两个循环依赖对象的创建过程-----------------------
	
	1. 尝试从 一级、二级、三级缓存中获取A，没获取到，开始创建
	
	2. 实例化A，构建一个 包含可获取A（或者 A的代理对象）方法（getEarlyBeanReference(beanName, mbd, bean)）的内部类 
	   实例 （new  ObjectFactory<Object>() ），并放到三级缓存
	
	3. 初始化A的属性值，需要依赖B，和1一样，尝试从缓存中获取B，没有获取到，开始创建
	
	4. 同2 ，实例化A，构建一个 可获取B（或者 B的代理对象）的内部类 实例（new  ObjectFactory<Object>() ），并放到三级缓存
	
	5. 同3 ，初始化B的属性值，需要依赖 A，尝试从缓存中获取 A，此时从三级缓存中获取到 2中放入的 new  ObjectFactory<Object>()对象
	
	6. 调用 new  ObjectFactory<Object>()对象 的getObject() 方法也就是 getEarlyBeanReference(beanName, mbd, bean) 方法 获取 A 的实际对象
       获取到的可能是一个A对象或A的代理对象 ProxyA，并将 A名称的bean 从三级缓存中移除，将获取到的A(ProxyA) 放入二级缓存
	   
	7. B的属性设置完毕，需要检查 B 是否在二级缓存，不在直接返回 B
	
	8. 将7返回的 B 添加到第一缓存。从第二第三缓存移除 返回 B
	
	9. 返回到 3， 将8返回的 B 设置为A的属性，初始化A属性完成
	
	10. 同7 检查 A 是否在二级缓存，当前A在二级缓存，将缓存中的对象 A（ProxyA） 返回
	
	11. 同8 ，将上面返回的 A（ProxyA） 添加到 第一缓存，移除第二第三缓存中的 A，返回 A（ProxyA）
	 
	
   ----------------SpringAop-----------------
	
	实例：定义一个 helloAspect 切面


	 <!-- 定义通知 对象 -->
     <bean id="helloAspect" class="cn.xie.dubbo.aspect.HelloAspect" > 
     </bean>
 
     <aop:config>
      <!-- 定义切面 包括切入点和通知 --> 
      <aop:aspect ref="helloAspect">
        <!--  定义切入点 --> 
        <aop:pointcut expression="execution(* *.getMchtInfo(..))" id="pcut"></aop:pointcut>
        <aop:before method="beforeSay"  pointcut-ref="pcut"></aop:before>
      </aop:aspect>
     </aop:config>
	
	之前构建bean流程一致，
	                     --------------- doCreateBean流程 ------------------
						 
					---->createBean(beanName, mbd, args)
			 
			             ---->resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)    	
				              //执行InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation 方法
							  
                         ---->doCreateBean(beanName, mbdToUse, args)
				
				              ----> createBeanInstance(beanName, mbd, args)
				                    //实例化对象 
									
					          ----> addSingletonFactory(beanName, new ObjectFactory<Object>())
							        //添加一个可获取对象（或代理对象）getObject() 内部类对象 到第三缓存
									
				              ----> populateBean(beanName, mbd, instanceWrapper)
				                    //初始化对象
					   
					                ---->InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation
					   
					                ---->InstantiationAwareBeanPostProcessor.postProcessPropertyValues
					   
					                ---->applyPropertyValues(beanName, mbd, bw, pvs);   //属性设置 
					   
				              ----> initializeBean(beanName, exposedObject, mbd)
				   
					                ---->invokeAwareMethods(beanName, bean);  //执行Aware接口方法
					   
					                ---->applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
					                      //执行 BeanPostProcessors 的   BeanPostProcessorsBeforeInitialization 方法 
						  
					                ---->invokeInitMethods(beanName, wrappedBean, mbd);
					                      // 执行（InitializingBean) bean).afterPropertiesSet()接口方法以及 init-method 自定义初始化方法
						  
					                ---->applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
					                      // 执行 BeanPostProcessors 的   BeanPostProcessorsAfterInitialization 方法  
						  
				              ----> return Object earlySingletonReference = getSingleton(beanName, false);
				                    //检查当前对象是否在二级缓存中，如果在则 替换当前bean（可能是一个代理对象） 并返回 
	
	1. 在执行到 resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)  方法时
	   调用 AspectJAwareAdvisorAutoProxyCreator.postProcessBeforeInstantiation 方法创建通知bean
	   
	   
		
		------------------AspectJAwareAdvisorAutoProxyCreator.postProcessBeforeInstantiation 执行过程-----------------------
		
		1.1 查找所有的通知bean名称，并缓存
		    findCandidateAdvisors()    //查找并初始化所有候选的通知对象
		    通过内部类 BeanFactoryAdvisorRetrievalHelperAdapter 对象缓存 所有通知bean名称
		
			执行过程
		    >>>AspectJAwareAdvisorAutoProxyCreator.postProcessBeforeInstantiation()   
		
				-->AspectJAwareAdvisorAutoProxyCreator.shouldSkip()   //判断是否需要忽略
		    
					-->AspectJAwareAdvisorAutoProxyCreator.findCandidateAdvisors()    //查找所有的通知
			  
						-->BeanFactoryAdvisorRetrievalHelperAdapter.findAdvisorBeans()     //查找所有的通知对象
				 
							-->DefaultListableBeanFactory.getBean()                         //没有则构建对象


		   

	
		1.2 构建 方式和普通对象一样
			<aop:before method="beforeSay"  pointcut-ref="pcut"></aop:before>
			定义了一个通知对象，流程先实例化一个
			org.springframework.aop.aspectj.AspectJPointcutAdvisor   
			对象（bean名称为 org.springframework.aop.aspectj.AspectJPointcutAdvisor#0）
		

			
			实例化时，由于beandefinition 定义了 构造方法参数，采用有参数构造方法的方式构造 AspectJPointcutAdvisor 对象
		
			看下 AspectJPointcutAdvisor 类的构造方法
			//Advisor 改造了  advice 通知对象，
			//可以简单理解为 Advisor 封装了 advice 通知的方法与 Pointcut pointcut 切入点对象

	
			public AspectJPointcutAdvisor(AbstractAspectJAdvice advice) {
				Assert.notNull(advice, "Advice must not be null");
				this.advice = advice;
				this.pointcut = advice.buildSafePointcut();
			}
		
		
		1.3 初始化 org.springframework.aop.aspectj.AspectJMethodBeforeAdvice 对象
		    bean名称为 (inner bean)#121314f7 
			同上: 采用构造函数方式实例化 AspectJMethodBeforeAdvice
			public AspectJMethodBeforeAdvice(
			    Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {
                super(aspectJBeforeAdviceMethod, pointcut, aif);
			}
			
		   需要 初始化  org.springframework.aop.config.MethodLocatingFactoryBean 方法执行对象 (inner bean)#576d5deb
		                org.springframework.aop.aspectj.AspectJExpressionPointcut  切入点对象 mchtCut
						org.springframework.aop.config.SimpleBeanFactoryAwareAspectInstanceFactory    (inner bean)#738dc9b
						
			都构建完成后，AspectJMethodBeforeAdvice 对象构建完成
			              AspectJPointcutAdvisor 对象构建完成
			
			
		     
			
			
	   	
	    
									
									
	2. 当执行到initializeBean，方法的 
	    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);方法时 返回的就是一个代理对象
		
	3. 具体代理对象生成交给 一个 BeanPostProcessor.postProcessAfterInitialization 生成
	   这个 BeanPostProcessor 就是 AspectJAwareAdvisorAutoProxyCreator 
	   
	4. 先看下 AspectJAwareAdvisorAutoProxyCreator.postProcessAfterInitialization(result, beanName) 方法
	
	                      --------------- postProcessAfterInitialization 流程 ---------------
	                      ----> postProcessAfterInitialization(result, beanName)
						  
						        ----> wrapIfNecessary(bean, beanName, cacheKey);
								
								      ----> getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
									  
									        ----> createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
											
	5. 最终调用的是 createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
	   
	   5.1 构建一个 代理工厂 对象，用于创建 代理
	       ProxyFactory proxyFactory = new ProxyFactory();
	       proxyFactory.copyFrom(this);
								     
									 
									 
	知识准备：								 
	---------------回顾一下 字节码-------------
				public String getFc()
				{
					try {
							return getDemode();
						}
						finally {
							invokeFinal();
						}
					}
	
	 0  aload_0 [this]                             //本地变量表0 位置推至栈顶
     1  invokevirtual cn.xie.dubbo.test.TestFinal.getDemode() : java.lang.String [35]  //this出栈，执行getDemode 结果入栈
     4  astore_2                                  // 栈顶结果放入本地变量表 2位置
     5  aload_0 [this]                            //本地变量表0 位置推至栈顶
     6  invokevirtual cn.xie.dubbo.test.TestFinal.invokeFinal() : void [37]         //this出栈，执行invokeFinal 
     9  aload_2                                    //本地变量表2 位置推至栈顶
    10  areturn                                     //返回栈顶结果
    11  astore_1
    12  aload_0 [this]
    13  invokevirtual cn.xie.dubbo.test.TestFinal.invokeFinal() : void [37]
    16  aload_1
    17  athrow
	 Exception Table:                              //异常表，pc：0 表示异常发生的起始指令地址（偏移）
        [pc: 0, pc: 5] -> 11 when : any                      pc：5 表示异常发生的结束指令地址（偏移）
		                                                     -> 11  ：发生异常的跳转指令地址偏移
															 when : any ：异常类型
															 
	//当发生异常时，检查当前异常是否与异常表的开始、结束，异常类型匹配，匹配上跳转指令至目标指令地址														 
	-------一个简单的责任链模式-------							   
	//方法过滤器接口
	public interface MethodInterceptor {
	  public Object invoke(MethodInvocation methodInvocation);
   }
	
	//前置通知过滤器
	public class MethodBeforeAdviceInterceptor implements MethodInterceptor{
	@Override
	public Object invoke(MethodInvocation methodInvocation) {
		System.out.println(" MethodBeforeAdviceInterceptor invoke ");
		return methodInvocation.proceed();
		}
	}
	
	//后置通知过滤器
	public class AspectJAfterAdvice implements MethodInterceptor{
	@Override
	public Object invoke(MethodInvocation methodInvocation) {
		// TODO Auto-generated method stub
		try{
			return methodInvocation.proceed();
		}finally
		{
			System.out.println(" AspectJAfterAdvice invoke ");
		}
	}
	}
	
	//方法执行接口
	public interface MethodInvocation {
      public Object proceed(); 
	}

	//实现的一个基于责任链的方法执行接口
	public class ReflectiveMethodInvocation implements MethodInvocation{
	
	//拦截器集合
	private MethodInterceptor[] methodInterceptors;  
	
	//当前拦截器索引
	int currentIndx;
	
	//目标方法
	TestFinal target;
	
	public ReflectiveMethodInvocation(TestFinal target)
	{
		methodInterceptors = new MethodInterceptor[]
				{new AspectJAfterAdvice(),new MethodBeforeAdviceInterceptor()};
		currentIndx = 0;
		this.target = target;
	}

	@Override
	public Object proceed() {
		//如果拦截器执行完成，执行目标方法
		if(currentIndx==methodInterceptors.length)
		{
			return target.invokeFinal();
		}
		else
		{
			//执行拦截器
			MethodInterceptor inter = methodInterceptors[currentIndx++];
			return inter.invoke(this);
		}
	}
	
	
	public static void main(String[] args) {

		ReflectiveMethodInvocation in = new ReflectiveMethodInvocation(new TestFinal());
		System.out.println(in.proceed());
	}

	}
	
	
	
	
	spring aop 方法执行过程和上面过程一致


-------------------------------------------------------------


@EnableDubbo 
包含两个注释
@EnableDubboConfig
@DubboComponentScan


--------------@EnableDubboConfig -------
@EnableDubboConfig = @Import(DubboConfigConfigurationRegistrar.class)
向 spring 中注册了
DubboConfigConfiguration.Single.class 

解析 DubboConfigConfiguration.Single.class 
  @EnableDubboConfigBindings({
            @EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class),
            @EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class)
    })  = @Import(DubboConfigBindingsRegistrar.class)
	
	
	通过 DubboConfigBindingsRegistrar 向 spring 注册了 配置文件中包含的 beandefenition
	ApplicationConfig.class
	ModuleConfig.class
	RegistryConfig.class
	ProtocolConfig.clas
	MonitorConfig.class
	ProviderConfig.class
    ConsumerConfig.class

--------------@DubboComponentScan--------------
=@Import(DubboComponentScanRegistrar.class)
DubboComponentScanRegistrar 想spring 注册了两个 bean
 registerServiceAnnotationBeanPostProcessor(packagesToScan, registry); //处理 @Service 标注
 为 ServiceAnnotationBeanPostProcessor 为 BeanDefinitionRegistryPostProcessor 接口对象
 此方法在 ApplicationContext .refresh()方法的 
 invokeBeanFactoryPostProcessors(configurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)执行BeanFactoryPostProcessor
 方法中执行
 
------------------ServiceAnnotationBeanPostProcessor----------------------------
 @Service
public class MchtInfoImpl implements MchtInfoInterface
@Service
public class UserServiceImpl implements OprInfoInterface
包下面配置了两个 服务器bean
 执行过程

 
 1.扫描包下面的类，查找@Service 标注的类，注册 MchtInfoImpl、UserServiceImpl  到 register 中（注册的为原始类，之后实例化时也是原始对象）
 2.扫描包下面的类，查找@Service  构建为 BeanDefinitionHolder 集合
 3.遍历 BeanDefinitionHolder 集合 （MchtInfoImpl，UserServiceImpl）
 4.使用@Service 参数，接口 MchtInfoInterface ，之前注册的 原始类的bean 名称 mchtInfoImpl
    构建 ServiceBean 类型的 BeanDefinition 
	BeanDefinition 的 ref = mchtInfoImpl
							interface = MchtInfoInterface(接口名)
	判断 @Service 参数 是否有配 provider、monitor、application、module参数，
	设置 BeanDefinition 的属性值设置为 @Service 参数中设定的值
	
 5.将 ServiceBean 类型的 BeanDefinition  注册到 register 中
 
 
--------------ServiceBean初始化-----------------
1.实例化 ServiceBean
2.设置根据 BeanDefinition 中配置的属性 设置 ServiceBean 的属性值
ServiceBean
   beanName="providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface"
   interfaceName="cn.xie.dubbo.iface.MchtInfoInterface"
   ref=MchtInfoImpl
 3.查找 ApplicationContext 中是否有 
    
    ProviderConfig
	ApplicationConfig
	ModuleConfig
	RegistryConfig
	MonitorConfig
	ProtocolConfig
	类型的bean
	这些bean 通过 @EnableDubboConfig   注解，通过读取配置文件，注册到 Spring 的 bean 中
	
	如果有，将 ServiceBean 的对应属性设置为相关配置的 bean 
	
	基本属性设置完成，通过 ServiceBean.export() 方法发布服务（通过判断 isDelay ，看什么时机发布服务）
	第一种情况，在属性设置完成时就发布
	第二种情况，在ApplicationContext 广播 ContextRefreshedEvent  事件时发布
	
	
	重点研究 ServiceBean.export() 方法
	
	实际调用的是 父类 ServiceConfig. doExport(); 方法
	
	------------ServiceConfig. doExport()---------------
	
	1. 检查必要配置  checkApplication(); checkRegistry();checkProtocol();
	2.调用 ServiceConfig. doExportUrls() 方法 
	3.获取 发布服务 url （为 redis url=registry://128.160.11.24:6379/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo&dubbo=2.0.2&pid=11200&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&registry=redis&timestamp=1610096282222）
	4. 遍历 ServiceBean 中协议配置 protocolConfig （也就是说可以配置多个协议）
	   调用  doExportUrlsFor1Protocol(protocolConfig, registryURLs);
	   
	5.根据协议配置 protocolConfig ，应用配置 获取 本地协议的 服务 url 
	url =dubbo://128.160.16.30:30990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&bind.ip=128.160.16.30&bind.port=30990&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&methods=getMchtInfo&pid=5112&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&side=provider&timestamp=1610330106306
	
	
	-----------------------------------------------------
	6. 发布本地服务（injvm 本地协议 ，是一个伪协议，用于一个应用即包含服务端、又包含客户端，当客户端调用服务端服务时，直接调用而不需要走远程注册中心）
	//使用 scope ="remote" 关闭
	
	exportLocal(url);
	
	7. proxyFactory.getInvoker(ref, (Class) interfaceClass, local)
	   //proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); //获取动态扩展对象 默认配置的是 javassist 实现，上面有介绍（根据url 获取具体的执行方法）
	通过 代理动态扩展对象获取 执行器
	看下 jdk 动态代理实现
	
	//proxy = cn.xie.SimpleSpring.dubbo.service.MchtInfoImpl 被代理对象
	// type = cn.xie.dubbo.iface.MchtInfoInterface 代理接口
	//url = injvm://127.0.0.1/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&bind.ip=128.160.16.30&bind.port=30990&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&methods=getMchtInfo&pid=5592&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&side=provider&timestamp=1610331652979
	
	
	return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                Method method = proxy.getClass().getMethod(methodName, parameterTypes);
                return method.invoke(proxy, arguments);
            }
        };
	
	返回一个 AbstractProxyInvoker 对象，这个对象用来执行 被代理的方法
	
	8.   Exporter<?> exporter = protocol.export(
                    proxyFactory.getInvoker(ref, (Class) interfaceClass, local));
					
	根据动态协议发布 发布本地服务 根据 AbstractProxyInvoker  中的url ，发布本地服务
	上面的url 为 injvm 协议，所以返回的 是 
	InjvmProtocol.export(Invoker<T>) 方法
	
	ps.适配器  protocol 会封装包装对象 （责任链模式），所以会先执行 以下方法
	（包装方法，分别封装了 
	1.QosProtocolWrapper.export(Invoker<T>) 
	2.ProtocolFilterWrapper.export(Invoker<T>) 
	3.ProtocolListenerWrapper.export(Invoker<T>) ）， 
	
    最终 调用 @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);
    }
	方法返回一个 InjvmExporter 对象，
	
	9.将返回的 InjvmExporter 对象添加到 ServiceBean 的发布 exporters 集合中 
	
	10.本地服务发布成功
	
	-----------------------------------------------------------
	11.开始发布远程服务
	url = registry://128.160.11.24:6379/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo&dubbo=2.0.2&export=dubbo%3A%2F%2F128.160.16.30%3A30990%2Fcn.xie.dubbo.iface.MchtInfoInterface%3Fanyhost%3Dtrue%26application%3Ddubbo-demo%26bean.name%3Dproviders%3Adubbo%3Acn.xie.dubbo.iface.MchtInfoInterface%26bind.ip%3D128.160.16.30%26bind.port%3D30990%26dubbo%3D2.0.2%26generic%3Dfalse%26interface%3Dcn.xie.dubbo.iface.MchtInfoInterface%26methods%3DgetMchtInfo%26pid%3D2540%26qos.accept.foreign.ip%3Dfalse%26qos.enable%3Dtrue%26qos.port%3D30880%26side%3Dprovider%26timestamp%3D1610334281909&pid=2540&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&registry=redis&timestamp=1610334281909
	
	Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
	
	根据 被代理对象 ref=cn.xie.SimpleSpring.dubbo.service.MchtInfoImpl
	接口对象 interfaceClass  interfaceClass =  cn.xie.dubbo.iface.MchtInfoInterface
	url 构建代理执行器 AbstractProxyInvoker 
	
	
	ps.AbstractProxyInvoker 为执行方法的代理对象，根据 被代理对象 MchtInfoImpl ，invocation 的 方法名称、方法参数，使用反射的方式执行 被代理对象 的方法
	
	 @Override
    public Result invoke(Invocation invocation) throws RpcException {
        try {
            return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
        } catch (InvocationTargetException e) {
            return new RpcResult(e.getTargetException());
        } catch (Throwable e) {
            throw new RpcException("Failed to invoke remote proxy method " + invocation.getMethodName() + " to " + getUrl() + ", cause: " + e.getMessage(), e);
        }
    }

    protected abstract Object doInvoke(T proxy, String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Throwable;
	
	
	12. 封装提供者元数据 执行器 
	将上面的 AbstractProxyInvoker 执行器封装为 带有配置的执行器
	 DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
	 
    13. 执行 发布
	 
	 Exporter<?> exporter = protocol.export(wrapperInvoker);
	 
	 由于 wrapperInvoker 中包含 URL  属性，URL 属性设定的协议为 registry 
	 
	 所以调用的是 registry=com.alibaba.dubbo.registry.integration.RegistryProtocol 的 export方法（调用这个方法之前，protocol 由于 封装了 QosProtocolWrapper、ProtocolFilterWrapper、ProtocolListenerWrapper 对象 ）
	 
	 同样先调用 
	 
	1）、ProtocolFilterWrapper.export(Invoker<T>) line: 98	

	2）、QosProtocolWrapper.export(Invoker<T>) line: 60	
	
	3）、ProtocolListenerWrapper.export(Invoker<T>) line: 55	
	
	4）、最终调用 注册协议的 发布方法
	RegistryProtocol.export(Invoker<T>) line: 135	
	
	14、 本地先发布  ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker)
	     获取 发布的 providerurl =  dubbo://128.160.16.30:30990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&bind.ip=128.160.16.30&bind.port=30990&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&methods=getMchtInfo&pid=5124&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&side=provider&timestamp=1610346651770
		
	15、从  已经绑定的 服务中获取对应url 的服务，如果存在，直接返回
	//providerurl <--> exporter  
    private final Map<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<String, ExporterChangeableWrapper<?>>();
	ps: 这里用到双重锁检查确保单例
	
	16、使用 url 与 执行器 构建 执行器代理执行器 InvokerDelegete
	 
	17、protocol.export(invokerDelegete)
	       发布 执行方法
		   
		   由于 invokerDelegete 包含 url 属性 
		   
		   url =  dubbo://128.160.16.30:30990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&bind.ip=128.160.16.30&bind.port=30990&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&methods=getMchtInfo&pid=5124&qos.accept.foreign.ip=false&qos.enable=true&qos.port=30880&side=provider&timestamp=1610346651770
		   
		   protocol 使用 dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol
		   方法发布 dubbo 服务 （同样会经过 责任链的其他 Protocol ）
		   
		   1）ProtocolFilterWrapper.export(Invoker<T>) line: 100	
		   2）ProtocolListenerWrapper.export(Invoker<T>) line: 57	
		   3）QosProtocolWrapper.export(Invoker<T>) line: 62	
		   4）DubboProtocol.export(Invoker<T>) line: 229	 //最终调用 的 DubboProtocol 发布方法
		   
	18、 String key = serviceKey(url);  //key  = cn.xie.dubbo.iface.MchtInfoInterface:30990
        DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);  //构建一个 dubbo 协议的发布器
        exporterMap.put(key, exporter);                                                                             //将发布器添加到 发布器集合map 中
		
	     这个每一个接口端口对应一个 发布器 
		cn.xie.dubbo.iface.MchtInfoInterface:30990 <---> DubboExporter(invoker 执行方法代理对象)  
		cn.xie.dubbo.iface.OprInfoInterface:30990 <---> DubboExporter(invoker 执行方法代理对象)  
		
	19、查询当前 protocol 对象中是否有对应ip和端口的 服务端服务（也就是之前发布过端口）
	
	 private void openServer(URL url) {
        // find server.
        String key = url.getAddress();      //key = 128.160.16.30:30990
        //client can export a service which's only for server to invoke
        boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);
        if (isServer) {
            ExchangeServer server = serverMap.get(key);
            if (server == null) {
                serverMap.put(key, createServer(url));        //如果没有构建过服务端，则构建服务端：当第一个服务暴露时只需  MchtInfoInterface
            } else {
                // server supports reset, use together with override
                server.reset(url);                                      //如果构建过服务端，服务端重置：当第二个及之后的服务暴露时 OprInfoInterface
            }
        }
    }

		
	20、createServer(url)  构建  服务端 
	server = Exchangers.bind(url, requestHandler);
	这里用到了 请求适配器 requestHandler
	 private ExchangeHandler requestHandler = new ExchangeHandlerAdapter()
	 
	 这个requestHandler 简单来说就是根据不同参数分发不同请求给不同的执行方法 
	 Invoker<?> invoker = getInvoker(channel, inv);
	 
	  return invoker.invoke(inv);
	  
	  
	  21、获取网络层交换对象 type = header 
	  ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);
	  
	  最终获取的 Exchanger = HeaderExchanger （为dubbo 默认实现）
	  header=com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger
	  
	  22、构建交换对象
	  new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
	      第一步：绑定 url 和 处理器 到网络层服务
		              先获取 Transporter  ：  ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();
					  getTransporter().bind(url, handler);
					  
					  调用bind方法
					  
					  这里的 
						Transporter = NettyTransporter
						netty4=com.alibaba.dubbo.remoting.transport.netty4.NettyTransporter
						
						调用的 是 
						
						public class NettyTransporter implements Transporter {

											public static final String NAME = "netty";

											@Override
											public Server bind(URL url, ChannelHandler listener) throws RemotingException {
																	return new NettyServer(url, listener);
													}

											@Override
											public Client connect(URL url, ChannelHandler listener) throws RemotingException {
																	return new NettyClient(url, listener);
													}

										}
						
						return new NettyServer(url, listener);
						
						
						
			第二步：NettyServer.doOpen() 打开连接
			
			这里主要是 netty 的打开服务端 操作
			1.构建 bossGroup 、workGroup 
			
			2.获取netty 的处理器
			这个为构建netty 服务的重点
			   ch.pipeline()//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug
                                .addLast("decoder", adapter.getDecoder())
                                .addLast("encoder", adapter.getEncoder())
                                .addLast("handler", nettyServerHandler);
								
			逐个分析 处理器   .addLast("decoder", adapter.getDecoder())
			
			解码处理器，
			同样通过 适配器对象获取到 dubbo 的转码器 
			dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec
			
			
			
			
			
			
			23.当有dubbo 协议的请求发送到服务端时,经过 DecodeHandler 处理器
			DecodeHandler.received(Channel, Object) line: 51	
			
			---->HeaderExchangeHandler.received(Channel, Object) line: 173	
			
			       ----->HeaderExchangeHandler.handleRequest(ExchangeChannel, Request) line: 96	
				   
				            ----->DubboProtocol$1.reply(ExchangeChannel, Object) line: 104	
							        //最终调用的是 DubboProtocol 的内部类对象 ExchangeHandlerAdapter 
									//最重要的是以下两个方法
									  private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {

											public Object reply(ExchangeChannel channel, Object message) throws RemotingException {
           
												Invoker<?> invoker = getInvoker(channel, inv);  //根据请求获取 执行器（其实就是通过 DubboProtocol 的 exporterMap 集合中获取到对应的 发布器，在获取到对应的执行器）
																														//		cn.xie.dubbo.iface.MchtInfoInterface:30990 <---> DubboExporter(invoker 执行方法 MchtInfoImpl bean 代理对象)  
		                                                                                                                //      cn.xie.dubbo.iface.OprInfoInterface:30990  <---> DubboExporter(invoker 执行方法 UserServiceImpl bean 代理对象)  
												return invoker.invoke(inv);                                  //执行执行器
         
										}

						



			
			
			

		  
		
		


	
	



	

	
	



 
 
 
 @Reference(loadbalance="roundrobin")
	private MchtInfoInterface mchtServer;
 
 registerReferenceAnnotationBeanPostProcessor(registry);   //处理 @Refenence 标注
 注册
 com.alibaba.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor 为 BeanPostProcessor bean的后置处理器，用来给属性赋值（在spring bean的初始化流程中有详情） 
 执行过程
    ReferenceAnnotationBeanPostProcessor(AnnotationInjectedBeanPostProcessor<A>).postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) 
			--->AnnotationInjectedBeanPostProcessor$AnnotatedInjectionMetadata(InjectionMetadata).inject(Object, String, PropertyValues) 
				--->AnnotationInjectedBeanPostProcessor$AnnotatedFieldElement.inject(Object, String, PropertyValues) 
					  --->ReferenceAnnotationBeanPostProcessor(AnnotationInjectedBeanPostProcessor<A>).getInjectedObject(A, Object, String, Class<?>, InjectedElement) 
							---->ReferenceAnnotationBeanPostProcessor.doGetInjectedBean(Annotation, Object, String, Class, InjectionMetadata$InjectedElement) 
									---->ReferenceAnnotationBeanPostProcessor.doGetInjectedBean(Reference, Object, String, Class<?>, InjectedElement) 
											--->ReferenceAnnotationBeanPostProcessor.buildReferenceBeanIfAbsent(String, Reference, Class<?>, ClassLoader) 



 
 
 1.构建 引用bean 
   // referencedBeanName = consumers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface 
   // reference = @Refenence 标注元数据
   // referencedType = cn.xie.dubbo.iface.MchtInfoInterface 接口
    ReferenceAnnotationBeanPostProcessor.buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class<?> referencedType, ClassLoader) 
	
    这里先从缓存中 ReferenceBean<?> referenceBean = referenceBeanCache.get(referencedBeanName); 看是否有缓存
	
2.  如果没有缓存 ，则构建一个 referenceBean 

 ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder
                    .create(reference, classLoader, applicationContext)
                    .interfaceClass(referencedType);
            referenceBean = beanBuilder.build();
            referenceBeanCache.put(referencedBeanName, referenceBean);
			
			这里构建出的 referenceBean =com.alibaba.dubbo.config.spring.ReferenceBean<T>  对象
			将 
			1）ApplicationConfig\ModuleConfig\RegistryConfig\MonitorConfig 
			2）applicationContext	
			3）interfaceClass	Class<T> (cn.xie.dubbo.iface.MchtInfoInterface) 
			属性初始化
			
3.构建完成将 referenceBean 放入 缓存 referenceBeanCache 中 

4. 缓存 referenceBean 到 injectedFieldReferenceBeanCache 中

5.构建代理对象

  buildProxy(referencedBeanName, referenceBean, injectedType);
  referencedBeanName=consumers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface （引用bean的名称）
  referenceBean  =  com.alibaba.dubbo.config.spring.ReferenceBean<T>  （上面构建的 引用bean）
  injectedType = cn.xie.dubbo.iface.MchtInfoInterface （接口）

 6. jdk动态代理步骤
    1）构建 InvocationHandler
	2）Proxy.newProxyInstance 生成代理对象
        InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);
        Object proxy = Proxy.newProxyInstance(getClassLoader(), new Class[]{injectedType}, handler);
        return proxy; 
		
  7.构建 InvocationHandler
  
     先看下 ReferenceBeanInvocationHandler 的属性
	 
	 private static class ReferenceBeanInvocationHandler implements InvocationHandler {

        private final ReferenceBean referenceBean;  //这个是 引用对象，其实是具体执行对象的封装对象

        private Object bean;                                   //这个是具体的执行对象
		
		
		
    1）先从 InvocationHandler 的缓存 localReferenceBeanInvocationHandlerCache 中获取 consumers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface 对应名称的  InvocationHandler
	
	如果没有 则构建一个 
	private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) {
            this.referenceBean = referenceBean;
        }
		
		
    2）InvocationHandler 初始化  handler.init();
	   其作用用来构建具体的执行 对象  private Object bean;  
	   
	   private void init() {
            this.bean = referenceBean.get();
        }
		这里就是将 referenceBean 的 ref 属性值赋给bean ，由于 ref 构建时还是空的，再执行 
		
		ReferenceBean. init(); 方法
		----->ref = ReferenceBean.createProxy(map);   //这里的map 中放入的 是
		          side=consumer
				  application=dubbo-client
				  register.ip=128.160.16.30
				  methods=getMchtInfo
				  qos.port=44444
				  loadbalance=roundrobin
				  interface=cn.xie.dubbo.iface.MchtInfoInterface
				  等配置信息
				  
				----->List<URL> us = loadRegistries(false);  从注册配置中收集 注册中心地址
                         这里的注册中心 是 redis  注册中心
						 us = [registry://128.160.11.24:6379/com.alibaba.dubbo.registry.RegistryService?application=dubbo-client&dubbo=2.0.2&pid=2624&qos.accept.foreign.ip=false&qos.enable=true&qos.port=44444&registry=redis&timestamp=1610502201869]
						 
						 
				------>invoker = refprotocol.refer(interfaceClass, urls.get(0));
						根据接口与url生成执行器对象
						
						refprotocol 一样是动态适配模式调用 refer() 方法
				     
					 ----->RegistryProtocol.doRefer(Cluster, Registry, Class<T>, URL) line: 308	
					         调用注册协议注册 消费者
							 consumer://128.160.16.30/cn.xie.dubbo.iface.MchtInfoInterface?application=dubbo-client&category=consumers&check=false&dubbo=2.0.2&interface=cn.xie.dubbo.iface.MchtInfoInterface&loadbalance=roundrobin&methods=getMchtInfo&pid=7680&qos.accept.foreign.ip=false&qos.enable=true&qos.port=44444&side=consumer&timestamp=1610504061856, dubbo version: 2.6.6, current host: 128.160.16.30
							 
							 ----->从注册中心获取 provider 的值 url 
							 dubbo://128.160.16.30:31990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-client&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&check=false&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&loadbalance=roundrobin&methods=getMchtInfo&pid=6492&qos.accept.foreign.ip=false&qos.enable=true&qos.port=44444&register.ip=128.160.16.30&remote.timestamp=1610504052257&side=consumer&timestamp=1610504773465
							 
					                ----->通过url 获取客户端---》服务端连接 
									       最终调用的是 DubboProtocol.getSharedClient(URL) 获取客户端
                                           这里的 也是先从 referenceClientMap 获取是否有对应 ip 和端口的客户端连接 128.160.16.30:31990
									 
						
		
		
	
 
 
 
 
 ---------------调用 过程-----------------------------
 给 @Refenence 注解的属性注入的是 代理对象 $Proxy64.getMchtInfo(String)  执行的 是 
 ReferenceAnnotationBeanPostProcessor$ReferenceBeanInvocationHandler.invoke(Object, Method, Object[]) 方法
 
 

com.alibaba.dubbo.common.bytecode.proxy0@7d62599d
  代理对象
    调用 com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(Object proxy, Method method, Object[] args)
	
	          ------>return invoker.invoke(new RpcInvocation(method, args)).recreate();
						------>MockClusterInvoker<T>.invoke(Invocation) line: 70	
								------>FailoverClusterInvoker<T>(AbstractClusterInvoker<T>).invoke(Invocation) line: 230	
								           //具体的分发流程
								           //checkWhetherDestroyed();
                                             LoadBalance loadbalance = null;

											// binding attachments into invocation.
											Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();
											if (contextAttachments != null && contextAttachments.size() != 0) {
											((RpcInvocation) invocation).addAttachments(contextAttachments);
											}
											// 这里获取到注册的 服务端服务列表（如果存在两个服务端，则返回两个执行器）
											// list[0]=dubbo://128.160.16.30:30990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-client&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&check=false&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&loadbalance=roundrobin&methods=getMchtInfo&pid=6396&qos.accept.foreign.ip=false&qos.enable=true&qos.port=44444&register.ip=128.160.16.30&remote.timestamp=1610413556565&side=consumer&timestamp=1610413597928
											// list[1]=dubbo://128.160.16.30:31990/cn.xie.dubbo.iface.MchtInfoInterface?anyhost=true&application=dubbo-demo&bean.name=providers:dubbo:cn.xie.dubbo.iface.MchtInfoInterface&dubbo=2.0.2&generic=false&interface=cn.xie.dubbo.iface.MchtInfoInterface&methods=getMchtInfo&pid=6540&side=provider&timestamp=1610413585975
											List<Invoker<T>> invokers = list(invocation);
											//获取负载均衡 对象
											if (invokers != null && !invokers.isEmpty()) {
													loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()
													.getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));
												}
											//通过负载均衡执行
											RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
											return doInvoke(invocation, invokers, loadbalance);
	
具体例子

@Reference(loadbalance="roundrobin")
	private MchtInfoInterface mchtServer;
	
	调用 方法 
 mchtServer.getMchtInfo("")
     ------>  $Proxy64 的 getMchtInfo 方法 
	           handler = com.alibaba.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor$ReferenceBeanInvocationHandler
                result = method.invoke(bean, args);
				bean = proxy0 
				----->proxy0  为 接口 cn.xie.dubbo.iface.MchtInfoInterface 代理对象 面通过初始化 构建了此代理对象
			   handler = com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler
			  
			  ----->InvokerInvocationHandler.invoke(Object, Method, Object[]) line: 52	
			           ---->MockClusterInvoker<T>.invoke(Invocation) line: 70	
							---->FailoverClusterInvoker<T>(AbstractClusterInvoker<T>).invoke(Invocation) line: 229	
			  
       
 
 
 
 总结下：
 
 Invoker 在客户端为远程方法调用对象，用来执行远程方法，由 动态适配对象获取 RegistryProtocol.doRefer(Cluster, Registry, Class<T>, URL) 
             在服务端为本地方法调用对象，用来执行对应bean 的方法，由 proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); 构建
			 
  ClusterInvoker： 客户端调用服务端集群执行入口（聚合执行器，为多个服务提供者构建的执行器）
         一般的实现为 FailoverClusterInvoker （）
		       包含： direcotory （RegisterDirectory）注册 的服务提供者地址和具体的执行器的目录
		  	   
  LoadBalance loadbalance ：负载均衡器，用来从 direcotory 中的服务提供者列表中选择具体的执行器
  
  Cluster：集群容错接口，通过 Cluster.join() 方法，可以获取具体的 ClusterInvoker 
              比如 默认的 FailoverCluster 
             return new FailoverClusterInvoker<T>(directory); 返回一个 失败自动切换的 执行器
  
 
 
 
 dubbo层级接口
 
 Service : interface
 
 Config : ReferenceConfig /ServiceConfig
 
 Proxy : Proxy /ProxyFactory/Invoker
 
 -Registry
 
 Cluster
 
 -Monitor
 
 Protocol
 
 Exchange
 
 Transport
 
 Serialize
 
 
--------------- Consumer---------------
 Interface ---> Proxy ---->Filter----->Involer(Cluster)---->Directory(Registry)
                                                                             ---->LoadBalance()
 
 
 
 
 
 
 
 
---------------负载均衡原理----------------
return doInvoke(invocation, invokers, loadbalance);

invocation//执行参数信息
invokers //执行器集合 注册中心注册的不同服务器的相同服务
loadbalance //负载均衡对象

























-------------------config 配置层--------------------
对外配置接口，以 ServiceConfig , ReferenceConfig
为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类

ServiceConfig 为提供者的配置，通过 export(); 发布服务

ReferenceConfig 为消费者配置，通过 get(); 获取远程服务

-----------------proxy 服务代理层----------------

proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端
Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory


---------------registry 注册中心层---------------
封装服务地址的注册与发现，以服务 URL 为中心，扩
展接口为 RegistryFactory , Registry , RegistryService

RegistryFactory 通过扩展点加载方式获取 具体的 RegistryFactory （DubboRegistryFactory，MulticastRegistryFactory，RedisRegistryFactory）
再通过具体的 RegistryFactory 构建 Registry 实例 （RedisRegistry、DubboRegistry）
     回顾之前的扩展点加载方式 

	 ps.
	 /*
	@Adaptive({"protocol"})
    Registry getRegistry(URL url);
	 
	 RegistryFactory factory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
	 //通过字节码构建一个 RegistryFactory 类对象
	 //类的具体动态方法如下
	 
	 public class RegistryFactory$Adaptive implements com.alibaba.dubbo.registry.RegistryFactory {

     public com.alibaba.dubbo.registry.Registry getRegistry(com.alibaba.dubbo.common.URL arg0) {

      if (arg0 == null) throw new IllegalArgumentException("url == null");
       com.alibaba.dubbo.common.URL url = arg0;
       String extName = ( url.getProtocol() == null ? "dubbo" : url.getProtocol() );
        if(extName == null) throw new IllegalStateException("Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url(" + url.toString() + ") use keys([protocol])");
       com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory.class).getExtension(extName);
        return extension.getRegistry(arg0);
      }
	 
     Registry regis = factory.getRegistry(url);
	 
	 //调用此方法通过 Protocol 属性值获取具体的 RedisRegistryFactory ，再返回 RedisRegistryFactory.getRegistry 方法
	 */
	 
	 
	 以 RedisRegistry 实现来说，
	 
	  URL url = new URL("dubbo","128.160.11.24",9001);
     url = urlr.setServiceInterface("cn.xie.dubbo.iface.MchtInfoInterface");
	 
	 RedisRegistry.register(url);
	 获取key = /dubbo/cn.xie.dubbo.iface.MchtInfoInterface/providers
	 value = dubbo://128.160.11.24:9001?interface=cn.xie.dubbo.iface.MchtInfoInterface
	 expire = 1611818170194
	 
	 添加到redis中， 
	 jedis.hset(key, value, expire);
	 jedis.publish(key, Constants.REGISTER);
	 发布 /dubbo/cn.xie.dubbo.iface.MchtInfoInterface/providers 通道的消息
	 
	 
	 regis.subscribe（url，NotifyListener）
	 订阅通知
	 

-----------------cluster 路由层(集群)---------------

cluster 路由层(集群)：封装多个提供者的路由及负载均衡，并桥接注册中心，以
Invoker 为中心，扩展接口为 Cluster , Directory , Router ,
LoadBalance

monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，
扩展接口为 MonitorFactory , Monitor , MonitorService

protocol 远程调用层：封将 RPC 调用，以 Invocation , Result 为中
心，扩展接口为 Protocol , Invoker , Exporter

exchange 信息交换层：封装请求响应模式，同步转异步，以 Request ,
Response 为中心，扩展接口为 Exchanger , ExchangeChannel ,
ExchangeClient , ExchangeServer

transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中
心，扩展接口为 Channel , Transporter , Client , Server , Codec

serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization ,
ObjectInput , ObjectOutput , ThreadPool

